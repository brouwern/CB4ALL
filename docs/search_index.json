[["index.html", "Computational Biology for All! An introduction to bioinformatics and computational biology using R Preface", " Computational Biology for All! An introduction to bioinformatics and computational biology using R Avril Coglan and Nathan Brouwer 2021-01-05 Preface This book is based on Dr. Avril Coghlan’s A little book of R for bioinformatics.. Most of the text and code was originally written by Dr. Coghlan and distributed under the Creative Commons 3.0 license. I have edited, updated and augmented the book for use as a text for the University of Pittsburgh Department of Biological Science’s Computational Biology Course. To meet the needs of my course I have Edited the original HTML document into RMarkdown Post the book using bookdown Used the RStudio IDE instead of the basic R IDE Split up Coghlan’s original chapters into shorter lessons Placed functions written by Coghlan into an R package called biodata instead of requiring that they be loaded by hand. Changed which functions or packages are used; for example, replacing some SeqinR functions with rentrez functions Added additional plots and changed some plotting functions, such as using ggplot2 and ggpubr. Removed .jpg images; I hope to add these back Fixed typos, removed dead links, added additional links, turned links to hypertext, converted to American English (sorry!) Added summary sections at the beginning listing the functions, vocabulary, software, organism, accession numbers To compile this to PDF, you need XeLaTeX. You are recommended to install TinyTeX (which includes XeLaTeX): https://yihui.org/tinytex/. "],["introduction.html", "Chapter 1 Introduction", " Chapter 1 Introduction Introduction goes here… "],["downloading-r.html", "Chapter 2 Downloading R 2.1 Introduction to R 2.2 Installing R 2.3 Starting R", " Chapter 2 Downloading R By: Avril Coghlan. Adapted and edited by Nathan Brouwer. The following introduction to R is based on the first part of “How to install R and a Brief Introduction to R” by Avril Coghlan. For additional information see “Getting R onto your computer”. 2.1 Introduction to R R (www.r-project.org) is a commonly used free statistics software. R allows you to carry out statistical analyses in an interactive mode, as well as allowing simple programming. 2.2 Installing R To use R, you first need to install the R program on your computer. 2.2.1 Installing R on a Windows PC These instructions will focus on installing R on a Windows PC. However, I will also briefly mention how to install R on a Macintosh or Linux computer (see below). These steps have not been checked as of 8/13/2019 so there may be small variations in what the prompts are. Installing are, however, is basically that same as any other program. Clicking “Yes” etc on everything should work. Note that even if you have used R before its good to regularly update it to avoid conflicts with recently produced software. New releases of R are made very regularly (approximately once a month), as R is actively being improved all the time. It is worthwhile installing new versions of R regularly, to make sure that you have a recent version of R (to ensure compatibility with all the latest versions of the R packages that you have downloaded). To install R on your Windows computer, follow these steps: Go to https://cran.r-project.org/ Under “Download and Install R”, click on the “Windows” link. Under “Subdirectories”, click on the “base” link. On the next page, you should see a link saying something like “Download R 3.6.1 for Windows” (or R X.X.X, where X.X.X gives the version of R). Click on this link. You may be asked if you want to save or run a file “R-x.x.x-win32.exe”. Choose “Save” and save the file on the Desktop. Then double-click on the icon for the file to run it. You will be asked what language to install it in - choose English. The R Setup Wizard will appear in a window. Click “Next” at the bottom of the R Setup wizard window. The next page says “Information” at the top. Click “Next” again. The next page says “Select Destination Location” at the top. By default, it will suggest to install R in “C:Files” on your computer. Click “Next” at the bottom of the R Setup wizard window. The next page says “Select components” at the top. Click “Next” again. The next page says “Startup options” at the top. Click “Next” again. The next page says “Select start menu folder” at the top. Click “Next” again. The next page says “Select additional tasks” at the top. Click “Next” again. R should now be installing. This will take about a minute. When R has finished, you will see “Completing the R for Windows Setup Wizard” appear. Click “Finish”. To start R, you can do one of the following steps: Check if there is an “R” icon on the desktop of the computer that you are using. If so, double-click on the “R” icon to start R. If you cannot find an “R” icon, try the next step instead. Click on the “Start” button at the bottom left of your computer screen, and then choose “All programs”, and start R by selecting “R” (or R X.X.X, where X.X.X gives the version of R) from the menu of programs. The R console (a rectangle) should pop up: 2.2.2 How to install R on non-Windows computers (eg. Macintosh or Linux computers) These steps have not been checked as of 8/13/2019 so there may be small variations in what the prompts are. Installing are, however, is basically that same as any other program. Clicking “Yes” etc on everything should work. The instructions above are for installing R on a Windows PC. If you want to install R on a computer that has a non-Windows operating system (for example, a Macintosh or computer running Linux, you should download the appropriate R installer for that operating system at https://cran.r-project.org/ and follow the R installation instructions for the appropriate operating system at https://cran.r-project.org/doc/FAQ/R-FAQ.html#How-can-R-be-installed_003f . 2.3 Starting R To start R, Check if there is an “R” icon on the desktop of the computer that you are using. If so, double-click on the “R” icon to start R. If you cannot find an “R” icon, try the next step instead. You can also start R from the Start menu. Click on the “Start” button at the bottom left of your computer screen, and then choose “All programs”, and start R by selecting “R” (or R X.X.X, where X.X.X gives the version of R, eg. R 2.10.0) from the menu of programs. Say “Hi” to R and take a quick look at how it looks. Now say “Goodbye”, because we will never actually do any work in this version of R; instead, we’ll use the RStudio IDE (intregrated development environment). "],["downloading-the-rstudio.html", "Chapter 3 Downloading the RStudio 3.1 Installing the RStudio IDE 3.2 Getting to know RStudio 3.3 RStudio versus RStudio Cloud", " Chapter 3 Downloading the RStudio By: Nathan Brouwer 3.1 Installing the RStudio IDE R is a programming language, and when you download it there is also a basic GUI (graphical user interface) that you can access via the R icon. A brief overview of installing RStudio can be found here “Getting RStudio on to your computer” 3.2 Getting to know RStudio For a brief overview of RStudio see “Getting started with RStudio” A good overview of what the different parts of RStudio can be seen in the image in this tweet: https://twitter.com/RLadiesNCL/status/1138812826917724160?s=20 3.3 RStudio versus RStudio Cloud RStudio and RStudio cloud work almost identically, so anything you read about RStudio will apply to RStudio Cloud. "],["installing-r-packages.html", "Chapter 4 Installing R packages 4.1 Downloading packages with the RStudio IDE 4.2 Downloading packages with the function install.packages() 4.3 Using packages after they are downloaded", " Chapter 4 Installing R packages R is a programming language, and packages or libraries are bundles of software built using R. Most sessions using R involve using additional R packages. This is especially true for bioinformatics and computational biology. NOTE: If you are working in an RStudio Cloud environment organized by someone else (eg a course instructor), they likely are taking care of many of the package management issues. The following information is still useful to be familiar with. 4.1 Downloading packages with the RStudio IDE There is a point-and-click interface for installing R packages in RStudio. There is a brief introduction to downloading packages on this site: http://web.cs.ucla.edu/~gulzar/rstudio/ I’ve summarized it here: \"Click on the Packages tab in the bottom-right section and then click on install. The following dialog box will appear “In the Install Packages dialog, write the package name you want to install under the Packages field and then click install. This will install the package you searched for or give you a list of matching package based on your package text.” 4.2 Downloading packages with the function install.packages() The easiest way to install a package if you know its name is to use the function install.packages(). Note that it might be better to call this “download.packages” since after you install it, you also have to load it! Frequently I will include install.packages(…) at the beginning of a lesson the first time we use a package to make sure the package is downloaded. Note, however, that if you already have downloaded the package, running install.packages(…) will download a new copy. We’ll download a package used for plotting called ggplot2, which stands for “Grammar of Graphics.” To download ggplot, run the following command: install.packages(&quot;ggplot2&quot;) Often when you download a package you’ll see a fair bit of red text, and sometime other things will pop up. Usually there’s nothing of interest here, but sometimes you need to read things carefully over it for hints about why something didn’t work. 4.3 Using packages after they are downloaded To actually make the functions in package accessible you need to use the library() command. Note that this is not in quotes. library(ggplot2) "],["installing-bioconductor.html", "Chapter 5 Installing Bioconductor 5.1 Bioconductor 5.2 Installing BiocManager", " Chapter 5 Installing Bioconductor 5.1 Bioconductor R packages (aka “libraries”) can live in many places. Most are accessed via CRAN, the Comprehensive R Archieve Network. The bioinformatics and computational biology community also has its own package hosting system called Bioconductor. R has played an important part in the development and application of bioinformatics techniques in the 21th century. Bioconductor 1.0 was released in 2002 with 15 packages. As of winter 2021, there are almost 2000 packages in the current release! NOTE: If you are working in an RStudio Cloud environment organized by someone else (eg a course instructor), they likely are taking care of most of package management issues, inlcuding setting up Bioconductor. The following information is still useful to be familiar with. To interface with Bioconductor you need the BiocManager package. The Bioconductor people have put BiocManager on CRAN to allow you to set up interactions with Bioconductor. Note that if you have an old version of R you will need to upate it to interact with bioconductor. 5.2 Installing BiocManager BiocManager can be installed using the install.packages() packages command. install.packages(&quot;BiocManager&quot;) Once downloaded, BioManager needs to be explicitly loaded into your active R session library(BiocManager) Individual packages can then be downloaded using the install() command. BiocManager::install(&quot;Biostrings&quot;) Bioconductor has many dependencies - other packages which is relies on. When you install Bioconductor packages you may need to update these packages. If something seems to not be working during this process, restart R and being the Bioconductor installation process until things seem to work. Again, to actually load the Biostrings package into your active R sessions requires the libary() command: library(Biostrings) For more information on BiocManager see the vignette: https://cran.r-project.org/web/packages/BiocManager/vignettes/BiocManager.html "],["brief-introduction-to-r.html", "Chapter 6 Brief introduction to R 6.1 Vocabulary 6.2 R functions etc 6.3 A brief introduction to R 6.4 Links and Further Reading", " Chapter 6 Brief introduction to R By: Avril Coghlan. Adapted and edited by Nathan Brouwer. This chapter provides a brief introduction to R. At the end of are links to additional resources for getting started with R. 6.1 Vocabulary scalar vector list class numeric character assignmnet elements of an object indices attributes of an object arguement of a function 6.2 R functions etc &lt;- [ ] $ table() function c() log10() help(), ? help.search() RSiteSearch() mean() return() q() 6.3 A brief introduction to R You will type R commands into the RStudio console in order to carry out analyses in R. In the RStudio console you will see the R prompt starting with the symbol “&gt;”. “&gt;” will always be there at the beginning of each new command - don’t try to delete it. We type the commands needed for a particular task after this prompt. The command is carried out after you hit the Return key. Once you have started R, you can start typing in commands, and the results will be calculated immediately, for example: 2*3 ## [1] 6 Note that prior to the output of “6” it shows “[1]”. 10-3 ## [1] 7 Again, prior to the output of “7” it shows “[1]”. R can act like a basic calculator that you type command in to. You can also use it like a scientific calcualtor and create variables that store information. All variables (scalars, vectors, matrices, etc.) created by R are called objects. In R, we assign values to variables using an arrow. For example, we can assign the value 2*3 to the variable x using the command: x &lt;- 2*3 To view the contents of any R object, just type its name, and the contents of that R object will be displayed: x ## [1] 6 There are several possible different types of objects in R with fancy math names, including scalars, vectors, matrices, arrays, data frames, tables, and lists. The scalar variable x above is one example of an R object. While a scalar variable such as x has just one element, a vector consists of several elements. The elements in a vector are all of the same type (eg. numeric or characters), while lists may include elements such as characters as well as numeric quantities. To create a vector, we can use the c() (combine) function. For example, to create a vector called myvector that has elements with values 8, 6, 9, 10, and 5, we type: myvector &lt;- c(8, 6, 9, 10, 5) To see the contents of the variable myvector, we can just type its name and press enter myvector ## [1] 8 6 9 10 5 The [1] is the index of the first element in the vector. We can extract any element of the vector by typing the vector name with the index of that element given in square brackets. For example, to get the value of the 4th element in the vector myvector, we type: myvector[4] ## [1] 10 In contrast to a vector, a list can contain elements of different types, for example, both numeric and character elements. A list can also include other variables such as a vector. The list() function is used to create a list. For example, we could create a list mylist by typing: mylist &lt;- list(name=&quot;Fred&quot;, wife=&quot;Mary&quot;, myvector) We can then print out the contents of the list mylist by typing its name: mylist ## $name ## [1] &quot;Fred&quot; ## ## $wife ## [1] &quot;Mary&quot; ## ## [[3]] ## [1] 8 6 9 10 5 The elements in a list are numbered, and can be referred to using indices. We can extract an element of a list by typing the list name with the index of the element given in double square brackets (in contrast to a vector, where we only use single square brackets). Thus, we can extract the second and third elements from mylist by typing: mylist[c(2,3)] ## $wife ## [1] &quot;Mary&quot; ## ## [[2]] ## [1] 8 6 9 10 5 Elements of lists may also be named, and in this case the elements may be referred to by giving the list name, followed by “\\(”, followed by the element name. For example, mylist\\)name is the same as mylist[[1]] and mylist$wife is the same as mylist[[2]]: mylist$wife ## [1] &quot;Mary&quot; We can find out the names of the named elements in a list by using the attributes() function, for example: attributes(mylist) ## $names ## [1] &quot;name&quot; &quot;wife&quot; &quot;&quot; When you use the attributes() function to find the named elements of a list variable, the named elements are always listed under a heading “\\(names”. Therefore, we see that the named elements of the list variable mylist are called “name” and “wife”, and we can retrieve their values by typing mylist\\)name and mylist$wife, respectively. Another type of object that you will encounter in R is a table. For example, if we made a vector variable “mynames” containing the names of children in a class, we can use the table() function to produce a table variable that contains the number of children with each possible name: mynames &lt;- c(&quot;Mary&quot;, &quot;John&quot;, &quot;Ann&quot;, &quot;Sinead&quot;, &quot;Joe&quot;, &quot;Mary&quot;, &quot;Jim&quot;, &quot;John&quot;, &quot;Simon&quot;) Now make the table table(mynames) ## mynames ## Ann Jim Joe John Mary Simon Sinead ## 1 1 1 2 2 1 1 Note that there are two Johns and two Marys. We can store the table variable produced by the function table(), and call the stored table “mytable”, by typing: mytable &lt;- table(mynames) To access elements in a table variable, you need to use double square brackets, just like accessing elements in a list. For example, to access the fourth element in the table mytable (the number of children called “John”), we type: mytable[[4]] ## [1] 2 Alternatively, you can use the name of the fourth element in the table (“John”) to find the value of that table element: mytable[[&quot;John&quot;]] ## [1] 2 Functions in R usually require arguments, which are input variables (ie. objects) that are passed to them, which they then carry out some operation on. For example, the log10() function is passed a number, and it then calculates the log to the base 10 of that number: log10(100) ## [1] 2 In R, you can get help about a particular function by using the help() function. For example, if you want help about the log10() function, you can type: help(&quot;log10&quot;) When you use the help() function, a box or webpage will show up in one of the panes of RStudio with information about the function that you asked for help with. You can also use the ? next to the fuctnion ?log10 If you are not sure of the name of a function, but think you know part of its name, you can search for the function name using the help.search() and RSiteSearch() functions. The help.search() function searches to see if you already have a function installed (from one of the R packages that you have installed) that may be related to some topic you’re interested in. The RSiteSearch() function searches all R functions (including those in packages that you haven’t yet installed) for functions related to the topic you are interested in. For example, if you want to know if there is a function to calculate the standard deviation of a set of numbers, you can search for the names of all installed functions containing the word “deviation” in their description by typing: help.search(&quot;deviation&quot;) Among the functions that were found, is the function sd() in the “stats” package (an R package that comes with the standard R installation), which is used for calculating the standard deviation. In the example above, the help.search() function found a relevant function (sd() here). However, if you did not find what you were looking for with help.search(), you could then use the RSiteSearch() function to see if a search of all functions described on the R website may find something relevant to the topic that you’re interested in: RSiteSearch(&quot;deviation&quot;) The results of the RSiteSearch() function will be hits to descriptions of R functions, as well as to R mailing list discussions of those functions. We can perform computations with R using objects such as scalars and vectors. For example, to calculate the average of the values in the vector myvector (ie. the average of 8, 6, 9, 10 and 5), we can use the mean() function: mean(myvector) ## [1] 7.6 We have been using built-in R functions such as mean(), length(), print(), plot(), etc. We can also create our own functions in R to do calculations that you want to carry out very often on different input data sets. For example, we can create a function to calculate the value of 20 plus square of some input number: myfunction &lt;- function(x) { return(20 + (x*x)) } This function will calculate the square of a number (x), and then add 20 to that value. The return() statement returns the calculated value. Once you have typed in this function, the function is then available for use. For example, we can use the function for different input numbers (eg. 10, 25): myfunction(10) ## [1] 120 To quit R, type: q() 6.4 Links and Further Reading Some links are included here for further reading. For a more in-depth introduction to R, a good online tutorial is available on the “Kickstarting R” website, cran.r-project.org/doc/contrib/Lemon-kickstart. There is another nice (slightly more in-depth) tutorial to R available on the “Introduction to R” website, cran.r-project.org/doc/manuals/R-intro.html. Chapter 3 of Danielle Navarro’s book is an excellent intro to the basics of R. "],["downloading-ncbi-sequence-data-by-hand.html", "Chapter 7 Downloading NCBI sequence data by hand 7.1 Retrieving genome sequence data via the NCBI website", " Chapter 7 Downloading NCBI sequence data by hand By: Avril Coghlan. Adapted and edited by Nathan Brouwer. The following chapter was originally written by Avril Coghlan. It provides brief, basic information for how to access sequences via the internet. A subsequent vignette provides more details. 7.1 Retrieving genome sequence data via the NCBI website You can easily retrieve DNA or protein sequence data by hand from the NCBI Sequence Database via its website www.ncbi.nlm.nih.gov. Dengue DEN-1 DNA is a viral DNA sequence and its NCBI accession number is NC_001477. To retrieve the DNA sequence for the Dengue DEN-1 virus from NCBI, go to the NCBI website, type “NC_001477” in the Search box at the top of the webpage, and press the “Search” button beside the Search box. (While this is the normal workflow, accessions related to well-known organisms can sometimes turn up using a direct Google search. This is the case for NC_001477 - if you Google it you can go directly to the website with the genome sequence.) On the results page of a normal NCBI search you will see the number of hits to “NC_001477” in each of the NCBI databases on the NCBI website. There are many databases on the NCBI website, for example, PubMed and Pubmed Central contain abstracts from scientific papers, the Genes and Genomes database contains DNA and RNA sequence data, the Proteins database contains protein sequence data, and so on. Most biologist would do this type of work by hand from within their web browser, but it can also be done by writing small programs in scripting languages such as Python or R. In R, the rentrez package is a powerful tool for interecting with NCBI resource. In this tutorial we’ll focus on the web interface. Its good to remember, though, that almost anything done via the webpage can be automated using a computer script. A challenge when learning to use NCBI resources is that there is a tremendous amount of sequence information available and you need to learn how to sort through what the search results provide. As you are looking for the DNA sequence of the Dengue DEN-1 virus genome, you expect to see a hit in the NCBI Nucleotide database. This is indicated at the top of the page where it says “NUCLEOTIDE SEQUENCE” and lists “Dengue virus 1, complete genome.” When you click on the link for the Nucleotide database, it will bring you to the record for NC_001477 in the NCBI Nucleotide database. This will contain the name and NCBI accession of the sequence, as well as other details such as any papers describing the sequence. If you scroll down you’ll see the sequence also. If you need it, you can retrieve the DNA sequence for the DEN-1 Dengue virus genome sequence as a FASTA format sequence file in a couple ways. The easiest is just to copy and paste it into a text, .R, or other file. You can also click on “Send to” at the top right of the NC_001477 sequence record webpage (just to the left of the side bar; its kinda small). After you click on Send to you can pick several options. and then choose “File” in the menu that appears, and then choose FASTA from the “Format” menu that appears, and click on “Create file”. The sequence will then download. The default file name is sequence.fasta so you’ll probably want to change it. You can now open the FASTA file containing the DEN-1 Dengue virus genome sequence using a text editor like Notepad, WordPad, Notepad++, or even RStudio on your computer. To find a text editor on your computer search for “text” from the start menu (Windows) and usually one will come up. (Opening the file in a word processor like word isn’t recommended). "],["introduction-to-ncbi-databases.html", "Chapter 8 Introduction to NCBI databases 8.1 To do 8.2 The NCBI Sequence Database 8.3 The NCBI Sub-Databases 8.4 Searching for an accession number in the NCBI database 8.5 NCBI Sequence Format (NCBI Format) 8.6 RefSeq 8.7 Querying the NCBI Database 8.8 Querying the NCBI Database via the NCBI Website (for reference) 8.9 Example: finding the sequences published in Nature 460:352-358 (for reference)", " Chapter 8 Introduction to NCBI databases By: Avril Coghlan. Adapted and edited by Nathan Brouwer. This vignette provides an introduction to the general search features of the NCBI databases, including how to search by both accession numbers and other search parameters, such as specific papers. For example, if you don’t know the accession number of a sequence, you can locate it via a paper that worked on that sequence. 8.1 To do replicate searches in R using rentrez 8.2 The NCBI Sequence Database All published genome sequences are available over the internet, as it is a requirement of every scientific journal that any published DNA or RNA or protein sequence must be deposited in a public database. The main resources for storing and distributing sequence data are three large databases: the NCBI database (www.ncbi.nlm.nih.gov/), the *European Molecular Biology Laboratory (EMBL) database (https://www.ebi.ac.uk/ena), and the DNA Database of Japan (DDBJ)** database (www.ddbj.nig.ac.jp/). These databases collect all publicly available DNA, RNA and protein sequence data and make it available for free. They exchange data nightly, so contain essentially the same data. In this vignette we will discuss the NCBI database. Note however that it contains essentially the same data as in the EMBL/DDBJ databases. Sequences in the NCBI Sequence Database are identified by an accession number. This is a unique number that is only associated with one sequence. For example, the accession number NC_001477 is for the DEN-1 Dengue virus genome sequence. The accession number is what identifies the sequence. It is reported in scientific papers describing that sequence. As well as the sequence itself, for each sequence the NCBI database also stores some additional annotation data, such as the name of the species it comes from, references to publications describing that sequence, information on the structure of the protein, etc. Some of this annotation data was added by the person who sequenced a sequence and submitted it to the NCBI database, while some may have been added later by a human curator working for NCBI. 8.3 The NCBI Sub-Databases The NCBI database contains several sub-databases, the most important of which are: Nucleotide database: contains DNA and RNA sequences NCBI Protein database: contains protein sequences EST database: contains ESTs (expressed sequence tags), which are short sequences derived from mRNAs Genome database: contains DNA sequences for whole genomes PubMed: contains data on scientific publications 8.4 Searching for an accession number in the NCBI database The FASTA file format is a file format commonly used to store sequence information. The first line starts with the greater than character followed by a name and/or description for the sequence. Subsequent lines contain the sequence itself. ## &gt;mysequence1 ## ACATGAGACAGACAGACCCCCAGAGACAGACCCCTAGACACAGAGAGAG ## TATGCAGGACAGGGTTTTTGCCCAGGGTGGCAGTATG A FASTA file can contain more than one sequence. If a FASTA file contains many sequences, then for each sequence it will have a header line starting with greater than character followed by the sequence itself. ## &gt;mysequence1 ## ACATGAGACAGACAGACCCCCAGAGACAGACCCCTAGACACAGAGAGAG ## TATGCAGGACAGGGTTTTTGCCCAGGGTGGCAGTATG ## ## &gt;mysequence2 ## AGGATTGAGGTATGGGTATGTTCCCGATTGAGTAGCCAGTATGAGCCAG ## AGTTTTTTACAAGTATTTTTCCCAGTAGCCAGAGAGAGAGTCACCCAGT ## ACAGAGAGC 8.5 NCBI Sequence Format (NCBI Format) As mentioned above, for each sequence the NCBI database stores some extra information such as the species that it came from, publications describing the sequence, etc. This information is stored in the NCBI entry or NCBI record for the sequence. The NCBI entry for a sequence can be viewed by searching the NCBI database for the accession number for that sequence. The NCBI entries for sequences are stored in a particular format, known as NCBI format. To view the NCBI entry for the DEN-1 Dengue virus (which has accession NC_001477), follow these steps: Go to the NCBI website (www.ncbi.nlm.nih.gov). Search for the accession number. On the results page, if your sequence corresponds to a nucleotide (DNA or RNA) sequence, you should see a hit in the Nucleotide database, and you should click on the word “Nucleotide” to view the NCBI entry for the hit. Likewise, if your sequence corresponds to a protein sequence, you should see a hit in the Protein database, and you should click on the word “Protein” to view the NCBI entry for the hit. After you click on “Nucleotide” or “Protein” in the previous step, the NCBI entry for the accession will appear. The NCBI entry for an accession contains a lot of information about the sequence, such as papers describing it, features in the sequence, etc. The DEFINITION field gives a short description for the sequence. The ORGANISM field in the NCBI entry identifies the species that the sequence came from. The REFERENCE field contains scientific publications describing the sequence. The FEATURES field contains information about the location of features of interest inside the sequence, such as regulatory sequences or genes that lie inside the sequence. The ORIGIN field gives the sequence itself. 8.6 RefSeq When carrying out searches of the NCBI database, it is important to bear in mind that the database may contain redundant sequences for the same gene that were sequenced by different laboratories (because many different labs have sequenced the gene, and submitted their sequences to the NCBI database). There are also many different types of nucleotide sequences and protein sequences in the NCBI database. With respect to nucleotide sequences, some many be entire genomic DNA sequences, some may be mRNAs, and some may be lower quality sequences such as expressed sequence tags (ESTs, which are derived from parts of mRNAs), or DNA sequences of contigs from genome projects. That is, you can end up with an entry in the protein database based on sequence derived from a genomic sequence, from sequencing just the gene, and from other routes. Furthermore, some sequences may be manually curated so that the associated entries contain extra information, but the majority of sequences are uncurated. As mentioned above, the NCBI database often contains redundant information for a gene, contains sequences of varying quality, and contains both uncurated and curated data. As a result, NCBI has made a special database called RefSeq (reference sequence database), which is a subset of the NCBI database. The data in RefSeq is manually curated, is high quality sequence data, and is non-redundant; this means that each gene (or splice-form / isoform of a gene, in the case of eukaryotes), protein, or genome sequence is only represented once. The data in RefSeq is curated and is of much higher quality than the rest of the NCBI Sequence Database. However, unfortunately, because of the high level of manual curation required, RefSeq does not cover all species, and is not comprehensive for the species that are covered so far. To speed up searches and simplify the results in to can be very useful to just search RefSeq. However, for detailed and thorough work the full database should probably be searched and the results scrutinized. You can easily tell that a sequence comes from RefSeq because its accession number starts with particular sequence of letters. That is, accessions of RefSeq sequences corresponding to protein records usually start with NP_, and accessions of RefSeq curated complete genome sequences usually start with NC_ or NS_. 8.7 Querying the NCBI Database You may need to interrogate the NCBI Database to find particular sequences or a set of sequences matching given criteria, such as: The sequence with accession NC_001477 The sequences published in Nature 460:352-358 All sequences from Chlamydia trachomatis Sequences submitted by Caroline Cameron, a syphyllis researcher Flagellin or fibrinogen sequences The glutamine synthetase gene from Mycobacteriuma leprae Just the upstream control region of the Mycobacterium leprae dnaA gene The sequence of the Mycobacterium leprae DnaA protein The genome sequence of syphilis, Treponema pallidum subspp. pallidum All human nucleotide sequences associated with malaria There are two main ways that you can query the NCBI database to find these sets of sequences. The first possibility is to carry out searches on the NCBI website. The second possibility is to carry out searches from R using one of several packages that can interface with NCBI. As of October 2019 rentrez seems to be the best package for this.. Below, I will explain how to manually carry out queries on the NCBI database. 8.8 Querying the NCBI Database via the NCBI Website (for reference) NOTE: The following section is here for reference; you need to know its possible to refine searches but do not need to know any of these actual tags. If you are carrying out searches on the NCBI website, to narrow down your searches to specific types of sequences or to specific organisms, you will need to use “search tags”. For example, the search tags “[PROP]” and “[ORGN]” let you restrict your search to a specific subset of the NCBI Sequence Database, or to sequences from a particular taxon, respectively. Here is a list of useful search tags, which we will explain how to use below: [AC] NC_001477[AC] With a particular accession number [ORGN] Fungi[ORGN] From a particular organism or taxon [PROP] biomol_mRNA[PROP] Of a specific type (eg. mRNA) or from a specific database (eg. RefSeq) [JOUR] Nature[JOUR] Described in a paper published in a particular journal [VOL] 531[VOL] Described in a paper published in a particular journal volume [PAGE] 27[PAGE] Described in a paper with a particular start-page in a journal [AU] “Smith J”[AU] Described in a paper, or submitted to NCBI, by a particular author To carry out searches of the NCBI database, you first need to go to the NCBI website, and type your search query into the search box at the top. For example, to search for all sequences from Fungi, you would type “Fungi[ORGN]” into the search box on the NCBI website. You can combine the search tags above by using “AND”, to make more complex searches. For example, to find all mRNA sequences from Fungi, you could type “Fungi[ORGN] AND biomol_mRNA[PROP]” in the search box on the NCBI website. Likewise, you can also combine search tags by using “OR”, for example, to search for all mRNA sequences from Fungi or Bacteria, you would type “(Fungi[ORGN] OR Bacteria[ORGN]) AND biomol_mRNA[PROP]” in the search box. Note that you need to put brackets around “Fungi[ORGN] OR Bacteria[ORGN]” to specify that the word “OR” refers to these two search tags. Here are some examples of searches, some of them made by combining search terms using “AND”: NC_001477[AC] - With accession number NC_001477 Nature[JOUR] AND 460[VOL] AND 352[PAGE] - Published in Nature 460:352-358 “Chlamydia trachomatis”[ORGN] - From the bacterium Chlamydia trachomatis “Berriman M”[AU] - Published in a paper, or submitted to NCBI, by M. Berriman flagellin OR fibrinogen - Which contain the word “flagellin” or “fibrinogen” in their NCBI record “Mycobacterium leprae”[ORGN] AND dnaA - Which are from M. leprae, and contain “dnaA” in their NCBI record “Homo sapiens”[ORGN] AND “colon cancer” - Which are from human, and contain “colon cancer” in their NCBI record “Homo sapiens”[ORGN] AND malaria - Which are from human, and contain “malaria” in their NCBI record “Homo sapiens”[ORGN] AND biomol_mrna[PROP] - Which are mRNA sequences from human “Bacteria”[ORGN] AND srcdb_refseq[PROP] - Which are RefSeq sequences from Bacteria “colon cancer” AND srcdb_refseq[PROP] - From RefSeq, which contain “colon cancer” in their NCBI record Note that if you are searching for a phrase such as “colon cancer” or “Chlamydia trachomatis”, you need to put the phrase in quotes when typing it into the search box. This is because if you type the phrase in the search box without quotes, the search will be for NCBI records that contain either of the two words “colon” or “cancer” (or either of the two words “Chlamydia” or “trachomatis”), not necessarily both words. As mentioned above, the NCBI database contains several sub-databases, including the NCBI Nucleotide database and the NCBI Protein database. If you go to the NCBI website, and type one of the search queries above in the search box at the top of the page, the results page will tell you how many matching NCBI records were found in each of the NCBI sub-databases. For example, if you search for “Chlamydia trachomatis[ORGN]”, you will get matches to proteins from C. trachomatis in the NCBI Protein database, matches to DNA and RNA sequences from C. trachomatis in the NCBI Nucleotide database, matches to whole genome sequences for C. trachomatis strains in the NCBI Genome database, and so on: Alternatively, if you know in advance that you want to search a particular sub-database, for example, the NCBI Protein database, when you go to the NCBI website, you can select that sub-database from the drop-down list above the search box, so that you will search that sub-database. 8.9 Example: finding the sequences published in Nature 460:352-358 (for reference) NOTE: The following section is here for reference; you need to know its possible to refine searches but do not need to know any of these actual tags. For example, if you want to find sequences published in Nature 460:352-358, you can use the “[JOUR]”, “[VOL]” and “[PAGE]” search terms. That is, you would go to the NCBI website and type in the search box on the top: “Nature”[JOUR] AND 460[VOL] AND 352[PAGE], where [JOUR] specifies the journal name, [VOL] the volume of the journal the paper is in, and [PAGE] the page number. This should bring up a results page with “50890” beside the word “Nucleotide”, and “1” beside the word “Genome”, and “25701” beside the word “Protein”, indicating that there were 50890 hits to sequence records in the Nucleotide database, which contains DNA and RNA sequences, and 1 hit to the Genome database, which contains genome sequences, and 25701 hits to the Protein database, which contains protein sequences. If you click on the word “Nucleotide”, it will bring up a webpage with a list of links to the NCBI sequence records for those 50890 hits. The 50890 hits are all contigs from the schistosome worm Schistosoma mansoni. Likewise, if you click on the word “Protein”, it will bring up a webpage with a list of links to the NCBI sequence records for the 25701 hits, and you will see that the hits are all predicted proteins for Schistosoma mansoni. If you click on the word “Genome”, it will bring you to the NCBI record for the Schistosoma mansoni genome sequence, which has NCBI accession NS_00200. Note that the accession starts with “NS_”, which indicates that it is a RefSeq accession. Therefore, in Nature volume 460, page 352, the Schistosoma mansoni genome sequence was published, along with all the DNA sequence contigs that were sequenced for the genome project, and all the predicted proteins for the gene predictions made in the genome sequence. You can view the original paper on the Nature website at http://www.nature.com/nature/journal/v460/n7253/abs/nature08160.html. Note: Schistmosoma mansoni is a parasitic worm that is responsible for causing schistosomiasis, which is classified by the WHO as a neglected tropical disease. "],["downloading-sequences-from-uniprot-by-hand.html", "Chapter 9 Downloading sequences from UniProt by hand 9.1 Vocab 9.2 UniProt 9.3 Viewing the UniProt webpage for a protein sequence 9.4 Retrieving a UniProt protein sequence via the UniProt website", " Chapter 9 Downloading sequences from UniProt by hand By: Avril Coghlan. Adapted and edited by Nathan Brouwer. The original online version has images, though they are somewhat outdated. 9.1 Vocab RefSeq manual curation UniProt accession 9.2 UniProt In a previous vignette you learnt how to retrieve sequences from the NCBI database. The NCBI database is a key database in bioinformatics because it contains essentially all DNA sequences ever sequenced. As mentioned previously, a subsection of the NCBI database called RefSeq consists of high quality DNA and protein sequence data. Furthermore, the NCBI entries for the RefSeq sequences have been manually curated, which means that expert biologists employed by NCBI have added additional information to the NCBI entries for those sequences, such as details of scientific papers that describe the sequences. Another extremely important manually curated database is UniProt, which focuses on protein sequences. UniProt aims to contains manually curated information on all known protein sequences. While many of the protein sequences in UniProt are also present in RefSeq, the amount and quality of manually curated information in UniProt is much higher than that in RefSeq. For each protein in UniProt, the UniProt curators read all the scientific papers that they can find about that protein, and add information from those papers to the protein’s UniProt entry. For example, for a human protein, the UniProt entry for the protein usually includes information about the biological function of the protein, in what human tissues it is expressed, whether it interacts with other human proteins, and much more. All this information has been manually gathered by the UniProt curators from scientific papers, and the papers in which the found the information are always listed in the UniProt entry for the protein. Just like NCBI, UniProt also assigns an accession to each sequence in the UniProt database. Although the same protein sequence may appear in both the NCBI database and the UniProt database, it will have different NCBI and UniProt accessions. However, there is usually a link on the NCBI entry for the protein sequence to the UniProt entry, and vice versa. 9.3 Viewing the UniProt webpage for a protein sequence If you are given the UniProt accession for a protein, to find the UniProt entry for the protein, you first need to go the UniProt website, www.uniprot.org. At the top of the UniProt website, you will see a search box, and you can type the accession of the protein that you are looking for in this search box, and then click on the “Search” button to search for it. For example, if you want to find the sequence for the chorismate lyase protein from Mycobacterium leprae (the bacterium which causes leprosy), which has UniProt accession Q9CD83, you would type just “Q9CD83” in the search box and press “Search”. The UniProt entry for UniProt accession Q9CD83 will then appear in your web browser. Beside the heading “Organism” you can see the organism is given as Mycobacterium leprae. If you scroll down you’ll find a section Names and Taxonomy and beside the heading “Taxonomic lineage”, you can see “Bacteria - Actinobacteria - Actinobacteridae - Actinomycetales - Corynebacterineae - Mycobacteriaceae- Mycobacterium”. This tells us that Mycobacterium is a species of bacteria, which belongs to a group of related bacteria called the Mycobacteriaceae, which itself belongs to a larger group of related bacteria called the Corynebacterineae, which itself belongs to an even larger group of related bacteria called the Actinomycetales, which itself belongs to the Actinobacteridae, which itself belongs to a huge group of bacteria called the Actinobacteria. 9.3.1 Protein function Back up at the top under “organism” is says “Status”, which tells us the annotation score is 2 out of 5, that it is a “Protein inferred from homology”, which means what we know about it is derived from bioinformatics and computational tools, not lab work. Beside the heading “Function”, it says that the function of this protein is that it “Removes the pyruvyl group from chorismate to provide 4-hydroxybenzoate (4HB)”. This tells us this protein is an enzyme (a protein that increases the rate of a specific biochemical reaction), and tells us what is the particular biochemical reaction that this enzyme is involved in. At the end of this info it says “By similarity”, which again indicates that what we know about this protein comes from bioinformatics, not lab work. 9.3.2 Protein sequence and size Under Sequence we see that the sequence length is 210 amino acids long (210 letters long) and has a mass of 24,045 daltons. We can access the sequence as a FASTA file from here if we want and also carry out a BLAST search from a link on the right. 9.3.3 Other information Further down the UniProt page for this protein, you will see a lot more information, as well as many links to webpages in other biological databases, such as NCBI. The huge amount of information about proteins in UniProt means that if you want to find out about a particular protein, the UniProt page for that protein is a great place to start. 9.4 Retrieving a UniProt protein sequence via the UniProt website There are a couple different ways to retrieve the sequence. At the top of the page is a tab that say “Format” which brings you to a page with th FASTA file. You can copy and paste the sequence from here if you want. To save it as a file, go to the “File” menu of your web browser, choose “Save page as”, and save the file. Remember to give the file a sensible name (eg. “Q9CD83.fasta” for accession Q9CD83), and in a place that you will remember (eg. in the “My Documents” folder). For example, you can retrieve the protein sequences for the chorismate lyase protein from Mycobacterium leprae (which has UniProt accession Q9CD83) and for the chorismate lyase protein from Mycobacterium ulcerans (UniProt accession A0PQ23), and save them as FASTA-format files (eg. “Q9CD83.fasta” and “A0PQ23.fasta”, as described above. You can also put the UniProt information into an online Basket. If you do this for both Q9CD83 and A0PQ23 you can think click on Basket, select both entries, and carry out a pairwise alignment by clicking on Align. Mycobacterium leprae is the bacterium which causes leprosy, while Mycobacterium ulcerans is a related bacterium which causes Buruli ulcer, both of which are classified by the WHO as neglected tropical diseases. The M. leprae and M. ulcerans chorismate lyase proteins are an example of a pair of homologous (related) proteins in two related species of bacteria. If you downloaded the protein sequences for UniProt accessions Q9CD83 and A0PQ23 and saved them as FASTA-format files (eg. “Q9CD83.fasta” and “A0PQ23.fasta”), you could read them into R using the read.fasta() function in the SeqinR R package (as detailed in another Vignette) or a similar function from another package. Note that the read.fasta() function normally expects that you have put your FASTA-format files in the the working directory of R. For convenience so you can explore these sequences they have been saved in a special folder in the dayoff package and can be accessed like this for the Leprosy sequence # load dayoff library(dayoff) # locate the file within the package using system.file() file.1 &lt;- system.file(&quot;./extdata/Q9CD83.fasta&quot;,package = &quot;dayoff&quot;) # load seqinr library(&quot;seqinr&quot;) # load fasta leprae &lt;- read.fasta(file = file.1) lepraeseq &lt;- leprae[[1]] We can confirm str(lepraeseq) For the other sequence # locate the file within the package using system.file() file.1 &lt;- system.file(&quot;./extdata/A0PQ23.fasta&quot;,package = &quot;dayoff&quot;) # load fasta ulcerans &lt;- read.fasta(file = &quot;A0PQ23.fasta&quot;) ulceransseq &lt;- ulcerans[[1]] "],["sequence-databases.html", "Chapter 10 Sequence Databases 10.1 Querying the NCBI Database via R 10.2 Summary 10.3 Acknowledgements", " Chapter 10 Sequence Databases By: Avril Coghlan. Adapted and edited by Nathan Brouwer. 10.1 Querying the NCBI Database via R Instead of carrying out searches of the NCBI database on the NCBI website, you can carry out searches directly from R by using the SeqinR R package. It is possible to use the SeqinR R package to retrieve sequences from these databases. The SeqinR package was written by the group that created the ACNUC database in Lyon, France (http://pbil.univ-lyon1.fr/databases/acnuc/acnuc.html). The ACNUC database is a database that contains most of the data from the NCBI Sequence Database, as well as data from other sequence databases such as UniProt and Ensembl. An advantage of the ACNUC database is that it brings together data from various different sources, and makes it easy to search, for example, by using the SeqinR R package. As will be explained below, the ACNUC database is organised into various different ACNUC (sub)-databases, which contain different parts of the NCBI database, and when you want to search the NCBI database via R, you will need to specify which ACNUC sub-database the NCBI data that you want to query is stored in. To obtain a full list of the ACNUC sub-databases that you can access using SeqinR, you can use the “choosebank()” function from SeqinR: library(“seqinr”) # Load the SeqinR R package choosebank() # List all the sub-databases in ACNUC [1] “genbank” “embl” “emblwgs” “swissprot” [5] “ensembl” “hogenom” “hogenomdna” “hovergendna” [9] “hovergen” “hogenom4” “hogenom4dna” “homolens” [13] “homolensdna” “hobacnucl” “hobacprot” “phever2” [17] “phever2dna” “refseq” “nrsub” “greviews” [21] “bacterial” “protozoan” “ensbacteria” “ensprotists” [25] “ensfungi” “ensmetazoa” “ensplants” “mito” [29] “polymorphix” “emglib” “taxobacgen” “refseqViruses” Alas, the ACNUC sub-databases do not have a one-to-one correspondence with the NCBI sub-databases (the NCBI Protein database, NCBI EST database, NCBI Genome database, etc.)! Three of the most important sub-databases in ACNUC which can be searched from R are: “genbank”: this contains DNA and RNA sequences from the NCBI Sequence Database, except for certain classes of sequences (eg. draft genome sequence data from genome sequencing projects) “refseq”: this contains DNA and RNA sequences from Refseq, the curated part of the NCBI Sequence Database “refseqViruses”: this contains DNA, RNA and proteins sequences from viruses from RefSeq You can find more information about what each of these ACNUC databases contains by looking at the ACNUC website. You can carry out complex queries using the “query()” function from the SeqinR package. If you look at the help page for the query() function (by typing “help(query)”, you will see that it allows you to specify criteria that you require the sequences to fulfill. For example, to search for a sequence with a particular NCBI accession, you can use the “AC=” argument in “query()”. The “query()” function will then search for sequences in the NCBI Sequence Database that match your criteria. Just as you can use “AC=” to specify an accession in a search, you can specify that you want to find sequences whose NCBI records contain a certain keywords by using “K=” as an argument (input) to the “query()” function. Likewise you can limit a search to either DNA or mRNA sequences by using the “M=” argument for the “query()” function. Here are some more possible arguments you can use in the “query()” function: Argument Example Restricts your search to sequences: “AC=” “AC=NC_001477” With a particular accession number “SP=” “SP=Chlamydia” From a particular organism or taxon “M=” “M=mRNA” Of a specific type (eg. mRNA) “J=” “J=Nature” Described in a paper published in a particular journal “R=” “R=Nature/460/352” Described in a paper in a particular journal, volume and start-page “AU=” “AU=Smith” Described in a paper, or submitted to NCBI, by a particular author The full list of possible arguments for the “query()” funtion are given on its help page. Here are some examples using the query function: Input to the query() function Searches for sequences: “AC=NC_001477” With accession number NC_001477 “R=Nature/460/352” Published in Nature 460:352-358 “SP=Chlamydia trachomatis” From the bacterium Chlamydia trachomatis “AU=Berriman” Published in a paper, or submitted to NCBI, by someone called Berriman “K=flagellin OR K=fibrinogen” Which have the keyword ‘flagellin’ or ‘fibrinogen’ “SP=Mycobacterium leprae AND K=dnaA” Which are from M. leprae, and have the keyword “dnaA” “SP=Homo sapiens AND K=colon cancer” Which are from human, and have the keyword “colon cancer” “SP=Homo sapiens AND K=malaria” Which are from human, and have the keyword “malaria” “SP=Homo sapiens AND M=mrna” Which are mRNA sequences from human “SP=Bacteria” Which are sequences from Bacteria As explained above, the ACNUC database contains the NCBI sequence data organised into several sub-databases, and you can view the list of those sub-databases by using the “choosebank()” function from the SeqinR package. When you want to use “query()” to carry out a particular sub-database (eg. “genbank”, which contains DNA and RNA sequences from the NCBI Sequence Database), you need to first specify the database that you want to search by using the “choosebank()” function, for example: choosebank(“genbank”) # Specify that we want to search the ‘genbank’ ACNUC sub-database Likewise, to specify that we want to search the ‘refseq’ ACNUC sub-database, which contains sequences from the NCBI RefSeq database, we would type: choosebank(“refseq”) # Specify that we want to search the ‘refseq’ ACNUC sub-database Once you have specified which ACNUC sub-database you want to search, you can carry out a search of that sub-database by using the “query()” function. You need to pass the “query()” function both a name for your query (which you can make up), and the query itself (which will be in the format of the examples in the table above). For example, if we want to search for RefSeq sequences from Bacteria, we might decide to call our query “RefSeqBact”, and we would call the “query()” function as follows: query(“RefSeqBact”, “SP=Bacteria”) As explained below, the results of the search are stored in a list variable called “RefSeqBact”, and can be retrieved from that list variable. The last thing to do once you have completed your search is to close the connection to the ACNUC sub-database that you were searching, by typing: closebank() Thus, there are three steps involved in carrying out a query using SeqinR: first use “choosebank()” to select the ACNUC sub-database to search, secondly use “query()” to query the database, and thirdly use “closebank()” to close the connection to the ACNUC sub-database. Another example could be to search for mRNA sequences from the parasitic worm Schistosoma mansoni in the NCBI Nucleotide database. The appropriate ACNUC sub-database to search is the “genbank” ACNUC sub-database. We may decide to call our search “SchistosomamRNA”. Therefore, to carry out the search, we type in R: choosebank(“genbank”) query(“SchistosomamRNA”, “SP=Schistosoma mansoni AND M=mrna”) closebank() Example: finding the sequence for the DEN-1 Dengue virus genome Another example could be to search for the DEN-1 Dengue virus genome sequence, which has accession NC_001477. This is a viral genome sequence, and so should be in the ACNUC sub-database “refSeqViruses”. Thus to search for this sequence, calling our search “Dengue1”, we type in R: choosebank(“refseqViruses”) query(“Dengue1”, “AC=NC_001477”) The result of the search is now stored in the list variable Dengue1. Remember that a list is an R object that is like a vector, but can contain elements that are numeric and/or contain characters. In this case, the list Dengue1 contains information on the NCBI records that match the query (ie. information on the NCBI record for accession NC_001477). If you look at the help page for “query()”, the details of the arguments are given under the heading “Arguments”, and the details of the results (outputs) are given under the heading “Value”. If you read this now, you will see that it tells us that the result of the “query()” function is a list with six different named elements, named “call”, “name”, “nelem”, “typelist”, “req”, and “socket”. The content of each of these six named elements is explained, for example, the “nelem” element contains the number of sequences that match the query, and the “req” element contains their accession numbers. In our example, the list object Dengue1 is an output of the “query()” function, and so has each of these six named elements, as we can find out by using the “attributes()” function, and looking at the named elements listed under the heading “$names”: attributes(Dengue1) $names [1] “call” “name” “nelem” “typelist” “req” “socket” \\(class [1] &quot;qaw&quot; As explained in the brief introduction to R, we can retrieve the value for each of the named elements in the list Dengue1 by using “\\)”, followed by the element’s name, for example, to get the value of the element named “nelem” in the list Dengue1, we type: Dengue1$nelem [1] 1 This tells us that there was one sequence in the ‘refseqViruses’ ACNUC database that matched the query. This is what we would expect, as there should only be one sequence corresponding to accession NC_001477. To obtain the accession numbers of the sequence found, we can type: Dengue1$req [[1]] name length frame ncbicg “NC_001477” “10735” “0” “1” As expected, the accession number of the matching sequence is NC_001477. When you type “attributes(Dengue1)” you can see that there are two headings, “\\(names”, and “\\)class”. As explained above, the named elements of the list variable Dengue1 are listed under the heading “\\(names”. In fact, the headings “\\)names” and “\\(class” are two attributes of the list variable Dengue1. We can retrieve the values of the attributes of a variable using the “attr()” function. For example, to retrieve the value of the attribute “\\)names” of Dengue1, we type: attr(Dengue1, “names”) [1] “call” “name” “nelem” “typelist” “req” “socket” This gives us the value of the attribute “\\(names”, which contains the the names of the named elements of the list variable Dengue1. Similarly, we can retrieve the value of the a attribute “\\)class” of Dengue1, we type: attr(Dengue1, “class”) [1] “qaw” This tells us that the value of the attribute “$class” is “qaw”. The final step in retrieving a genomic DNA sequence is to use the “getSequence()” function to tell R to retrieve the sequence data. The command below uses “getSequence()” to retrieve the sequence data for the DEN-1 Dengue virus genome, and puts the sequence into a variable dengueseq: dengueseq &lt;- getSequence(Dengue1\\(req[[1]]) Note that the input to the getSequence() command is Dengue1\\)req[[1]], which contains the name of the NCBI record that the list Dengue1 contains information about. Once you have retrieved a sequence, you can then print it out. The variable dengueseq is a vector containing the nucleotide sequence. Each element of the vector contains one nucleotide of the sequence. Therefore, we can print out the first 50 nucleotides of the DEN-1 Dengue genome sequence by typing: dengueseq[1:50] [1] “a” “g” “t” “t” “g” “t” “t” “a” “g” “t” “c” “t” “a” “c” “g” “t” “g” “g” “a” [20] “c” “c” “g” “a” “c” “a” “a” “g” “a” “a” “c” “a” “g” “t” “t” “t” “c” “g” “a” [39] “a” “t” “c” “g” “g” “a” “a” “g” “c” “t” “t” “g” Note that dengueseq[1:50] refers to the elements of the vector dengueseq with indices from 1-50. These elements contain the first 50 nucleotides of the DEN-1 Dengue virus genome sequence. As well as retrieving the DNA (or RNA or protein) sequence itself, SeqinR can also retrieve all the annotations for the sequence, for example, information on when the sequence was sequenced, who sequenced it, what organism is it from, what paper was it described in, what genes were identified in the sequence, and so on. Once you have retrieved a sequence using SeqinR, you can retrieved its annotations by using the “getAnnot()” function. For example, to view the annotations for the DEN-1 Dengue virus genome sequence, we type: annots &lt;- getAnnot(Dengue1$req[[1]]) This stores the annotations information from the NCBI record for the DEN-1 Dengue virus sequence in a vector variable annots, with one line of the NCBI record in each element of the vector. Therefore, we can print out the first 20 lines of the NCBI record by typing: annots[1:20] [1] “LOCUS NC_001477 10735 bp ss-RNA linear VRL 08-DEC-2008” [2] “DEFINITION Dengue virus type 1, complete genome.” [3] “ACCESSION NC_001477” [4] “VERSION NC_001477.1 GI:9626685” [5] “DBLINK Project: 15306” [6] “KEYWORDS .” [7] “SOURCE Dengue virus 1” [8] \" ORGANISM Dengue virus 1\" [9] \" Viruses; ssRNA positive-strand viruses, no DNA stage; Flaviviridae;\" [10] \" Flavivirus; Dengue virus group.\" [11] “REFERENCE 1 (bases 1 to 10735)” [12] \" AUTHORS Puri,B., Nelson,W.M., Henchal,E.A., Hoke,C.H., Eckels,K.H.,\" [13] \" Dubois,D.R., Porter,K.R. and Hayes,C.G.\" [14] \" TITLE Molecular analysis of dengue virus attenuation after serial passage\" [15] \" in primary dog kidney cells\" [16] \" JOURNAL J. Gen. Virol. 78 (PT 9), 2287-2291 (1997)\" [17] \" PUBMED 9292016\" [18] “REFERENCE 2 (bases 1 to 10735)” [19] \" AUTHORS McKee,K.T. Jr., Bancroft,W.H., Eckels,K.H., Redfield,R.R.,\" [20] \" Summers,P.L. and Russell,P.K.\" On the left of the annotations, you will see that there is a column containing the field name. For example, the line of the with “ACCESSION” in the left column is the accession field, which contains the accession for the sequence (NC_001477 for the DEN-1 Dengue virus). The line with “ORGANISM” in the left column is the organism field, and usually contains the Latin name for the organism (“Dengue virus 1” here). The line with “AUTHORS” in the left column is the authors field, and contain the names of authors that wrote papers to describe the sequence and/or the names of the people who submitted the sequence to the NCBI Database. When you have finished your running your query and getting the corresponding sequences and annotations, close the connection to the ACNUC sub-database: closebank() Example: finding the sequences published in Nature 460:352-358 We described above how to search for the sequences published in Nature 460:352-358, using the NCBI website. A second method is to use the SeqinR R package to search the ACNUC databases (which contain the NCBI sequence data) from R. If you look at the help page the “query()” function, you see that you can query for sequences published in a particular paper using R=refcode, specifying the reference as refcode such as in jcode/volume/page (e.g., JMB/13/5432 or R=Nature/396/133). For the paper Nature 460:352-358, we would need to use the refcode ‘R=Nature/460/352’. First we need to specify which of the ACNUC databases we want to search. For example, to specify that we want to search the “genbank” ACNUC database, which contains DNA and RNA sequences from the NCBI Nucleotide database, we type: choosebank(“genbank”) # Specify that we want to search the ‘genbank’ ACNUC sub-database We can then search the ‘genbank’ database for sequences that match a specific set of criteria by using the “query()” function. For example, to search for sequences that were published in Nature 460:352-358, we type: query(‘naturepaper’, ‘R=Nature/460/352’) The line above tells R that we want to store the results of the query in an R list variable called naturepaper. To get the value of the element named “nelem” in the list naturepaper, we type: naturepaper$nelem [1] 19022 This tells us that there were 19022 sequences in the ‘genbank’ ACNUC database that matched the query. The ‘genbank’ ACNUC database contains DNA or RNA sequences from the NCBI Nucleotide database. Why don’t we get the same number of sequences as found by carrying out the search on the NCBI website (where we found 50890 hits to the NCBI Nucleotide database)? The reason is that the ACNUC ‘genbank’ database does not contain all the sequences in the NCBI Nucleotide database, for example, it does not contain sequences that are in RefSeq or many short DNA sequences from sequencing projects. To obtain the accession numbers of the first five of the 19022 sequences, we can type: accessions &lt;- naturepaper$req accessions[1:5] [[1]] name length frame ncbicg “FN357292” “4179495” “0” “1” [[2]] name length frame ncbicg “FN357293” “2211188” “0” “1” [[3]] name length frame ncbicg “FN357294” “1818661” “0” “1” [[4]] name length frame ncbicg “FN357295” “2218116” “0” “1” [[5]] name length frame ncbicg “FN357296” “3831198” “0” “1” This tells us that the NCBI accessions of the first five sequences (of the 19022 DNA or RNA sequences found that were published in Nature 460:352-358) are FN357292, FN357293, FN357294, FN357295, and FN357296. To retrieve these first five sequences, and print out the first 10 nucleotide bases of each sequence, we use the getSequence() command, typing: for (i in 1:5) { seqi &lt;- getSequence(naturepaper\\(req[[i]]) print(seqi[1:10]) } [1] &quot;t&quot; &quot;t&quot; &quot;g&quot; &quot;t&quot; &quot;c&quot; &quot;g&quot; &quot;a&quot; &quot;t&quot; &quot;t&quot; &quot;a&quot; [1] &quot;g&quot; &quot;g&quot; &quot;t&quot; &quot;c&quot; &quot;c&quot; &quot;t&quot; &quot;t&quot; &quot;a&quot; &quot;a&quot; &quot;g&quot; [1] &quot;g&quot; &quot;c&quot; &quot;c&quot; &quot;t&quot; &quot;g&quot; &quot;a&quot; &quot;c&quot; &quot;c&quot; &quot;a&quot; &quot;t&quot; [1] &quot;t&quot; &quot;a&quot; &quot;t&quot; &quot;t&quot; &quot;t&quot; &quot;c&quot; &quot;c&quot; &quot;a&quot; &quot;a&quot; &quot;t&quot; [1] &quot;c&quot; &quot;a&quot; &quot;a&quot; &quot;t&quot; &quot;c&quot; &quot;a&quot; &quot;c&quot; &quot;t&quot; &quot;c&quot; &quot;a&quot; Note that the input to the getSequence() command is Dengue1\\)req[[i]], which contains the name of i th NCBI record that the list naturepaper contains information about. Once we have carried out our queries and retrieved the sequences, the final step is to close the connection to the ACNUC sub-database that we searched (“genbank” here): closebank() Saving sequence data in a FASTA-format file Once you have retrieved a sequence, or set of sequences from the NCBI Database, using SeqinR, it is conveninent to save the sequences in a file in FASTA format. This can be done using the “write.fasta()” function in the SeqinR package, which was introduced in Chapter 1. If you look at the help page for the “write.fasta()” function, you will see that as input it takes a list of vectors, where each vector contains one DNA, RNA or protein sequence. For example, if you retrieve the sequences of human tRNAs from the NCBI Database by querying the ACNUC “genbank” sub-database, you can save the sequences in a FASTA format file called “humantRNAs.fasta” by typing: choosebank(“genbank”) # select the ACNUC sub-database to be searched query(“humtRNAs”, “SP=homo sapiens AND M=TRNA”) # specify the query myseqs &lt;- getSequence(humtRNAs) # get the sequences mynames &lt;- getName(humtRNAs) # get the names of the sequences write.fasta(myseqs, mynames, file.out=“humantRNAs.fasta”) closebank() In the above code, we get the sequences of the human tRNAs using the function “getSequence()” from the SeqinR package. We also use a function “getName()” from the SeqinR package to get the sequences’ names. Then we use the “write.fasta()” function to write the sequences to a FASTA file “humantRNAs.fasta”. The “write.fasta()” takes as arguments: the list myseqs containing the sequences, the list mynames containing the names of the sequences, and the name of the output file (“humantRNAs.fasta” here). Finding the genome sequence for a particular species Microbial genomes are generally smaller than eukaryotic genomes (Escherichia coli has about 5 million base pair in its genome, while the human genome is about 3 billion base pairs). Because they are considerably less expensive to sequence, many microbial genome sequencing projects have been completed. If you don’t know the accession number for a genome sequence (eg. for Mycobacterium leprae, the bacterium that causes leprosy), how can you find it out? The easiest way to do this is to look at the NCBI Genome website, which lists all fully sequenced genomes and gives the accession numbers for the corresponding DNA sequences. If you didn’t know the accession number for the Mycobacterium leprae genome, you could find it on the NCBI Genome website by following these steps: Go to the NCBI Genome website (http://www.ncbi.nlm.nih.gov/sites/entrez?db=Genome) On the homepage of the NCBI Genome website, it gives links to the major subdivisions of the Genome database, which include Eukaryota, Prokaryota (Bacteria and Archaea), and Viruses. Click on ‘Prokaryota’, since Mycobacterium leprae is a bacterium. This will bring up a list of all fully sequenced bacterial genomes, with the corresponding accession numbers. Note that more than one genome (from various strains) may have been sequenced for a particular species. Use ‘Find’ in the ‘Edit’ menu of your web browser to search for ‘Mycobacterium leprae’ on the webpage. You should find that the genomes of several different M. leprae strains have been sequenced. One of these is M. leprae TN, which has accession number NC_002677. The list of sequenced genomes on the NCBI Genomes website is not a definitive list; that is, some sequenced genomes may be missing from this list. If you want to find out whether a particular genome has been sequenced, but you don’t find it NCBI Genomes website’s list, you should search for it by following these steps: Go to the NCBI website (www.ncbi.nlm.nih.gov). Select ‘Genome’ from the drop-down list above the search box. Type the name of the species you are interested in in the search box (eg. “Mycobacterium leprae”[ORGN]). Press ‘Search’. Note that you could also have found the Mycobacterium leprae genome sequence by searching the NCBI Nucleotide database, as the NCBI Genome database is just a subset of the NCBI Nucleotide database. How many genomes have been sequenced, or are being sequenced now? On the NCBI Genome website (http://www.ncbi.nlm.nih.gov/sites/entrez?db=Genome), the front page gives a link to a list of all sequenced genomes in the groups Eukaryota, Prokaryota (Bacteria and Archaea) and Viruses. If you click on one of these links (eg. Prokaryota), at the top of the page it will give the number of sequenced genomes in that group (eg. number of sequenced prokaryotic genomes). For example, in this screenshot (from January 2011), we see that there were 1409 complete prokaryotic genomes (94 archaeal, 1315 bacterial): image1 Another useful website that lists genome sequencing projects is the Genomes OnLine Database (GOLD), which lists genomes that have been completely sequenced, or are currently being sequenced. To find the number of complete or ongoing bacterial sequencing projects, follow these steps: Go to the GOLD website (http://genomesonline.org/). Click on the yellow ‘Enter GOLD’ button in the centre of the webpage. On the subsequent page, it will give the number of ongoing bacterial, archaeal and eukaryotic genome sequencing projects. Click on the ‘Bacterial Ongoing’ link to see the list of ongoing bacterial genome sequencing projects. By default, just the first 100 projects are listed, and the rest are listed on subsequent pages. In one of the columns of the page, this gives the university or institute that the genome was sequenced in. Other columns give the taxonomic information for the organism, and links to the sequence data. Find the number of published genome sequencing projects. Go back one page, to the page with the ‘Bacterial Ongoing’ link. You will see that this page also lists the number of complete published genomes. To see a list of these genomes, click on ‘Complete Published’. This will bring up a page that gives the number of published genomes at the top of the page. In one column of the page, this gives the university or institute that the genome was sequenced in. As explained above, it is possible to identify genome sequence data in the NCBI Genome database. The GOLD database also gives some information about ongoing genome projects. Often, the GOLD database lists some ongoing projects that are not yet present in the NCBI Genome Database, because the sequence data has not yet been submitted to the NCBI Database. If you are interested in finding out how many genomes have been sequenced or are currently being sequenced for a particular species (eg. Mycobacterium leprae), it is a good idea to look at both the NCBI Genome database and at GOLD. 10.2 Summary In this chapter, you have learnt how to retrieve sequences from the NCBI Sequence database, as well as to find out how many genomes have been sequenced or are currently being sequenced for a particular species. Links and Further Reading There is detailed information on how to search the NCBI database on the NCBI Help website at http://www.ncbi.nlm.nih.gov/bookshelf/br.fcgi?book=helpentrez?part=EntrezHelp. There is more information about the GOLD database in the paper describing GOLD by Liolios et al, which is available at http://www.ncbi.nlm.nih.gov/pmc/articles/PMC2808860/?tool=pubmed. For more in-depth information and more examples on using the SeqinR package for sequence analysis, look at the SeqinR documentation, http://pbil.univ-lyon1.fr/software/seqinr/doc.php?lang=eng. There is also a very nice chapter on “Analyzing Sequences”, which includes examples of using SeqinR for sequence analysis, in the book Applied statistics for bioinformatics using R by Krijnen (available online at cran.r-project.org/doc/contrib/Krijnen-IntroBioInfStatistics.pdf). 10.3 Acknowledgements ’ Contact I will be grateful if you will send me (Avril Coghlan) corrections or suggestions for improvements to my email address alc@sanger.ac.uk License The content in this book is licensed under a Creative Commons Attribution 3.0 License. Exercises Answer the following questions. For each question, please record your answer, and what you did/typed to get this answer. Model answers to the exercises are given in Answers to the exercises on Sequence Databases. What information about the rabies virus sequence (NCBI accession NC_001542) can you obtain from its annotations in the NCBI Sequence Database? What does it say in the DEFINITION and ORGANISM fields of its NCBI record? Note: rabies virus is the virus responsible for rabies, which is classified by the WHO as a neglected tropical disease. How many nucleotide sequences are there from the bacterium Chlamydia trachomatis in the NCBI Sequence Database? Note: the bacterium Chlamydia trachomatis is responsible for causing trachoma, which is classified by the WHO as a neglected tropical disease. How many nucleotide sequences are there from the bacterium Chlamydia trachomatis in the RefSeq part of the NCBI Sequence Database? How many nucleotide sequences were submitted to NCBI by Matthew Berriman? How many nucleotide sequences from nematode worms are there in the RefSeq Database? Note that several parasitic nematode worms cause neglected tropical diseases, including Brugia malayi and Wucheria bancrofti, which cause lymphatic filariasis; Loa loa, which causes subcutaneous filariasis; Onchocerca volvulus, which causes onchocerciasis; and Necator americanus, which causes soil-transmitted helminthiasis. How many nucleotide sequences for collagen genes from nematode worms are there in the NCBI Database? How many mRNA sequences for collagen genes from nematode worms are there in the NCBI Database? How many protein sequences for collagen proteins from nematode worms are there in the NCBI database? What is the accession number for the Trypanosoma cruzi genome in NCBI? Do you see genome sequences for more than one strain of Trypanosoma cruzi? Note that the Trypanosoma cruzi causes Chagas disease, which is classified as a neglected tropical disease by the WHO. How many fully sequenced nematode worm species are represented in the NCBI Genome database? "],["local-variation-in-gc-content-not-updated.html", "Chapter 11 Local variation in GC content - NOT UPDATED 11.1 Vocabulary 11.2 Reading sequence data with rentrez::entrez_fetch 11.3 Local variation in GC content 11.4 A sliding window analysis of GC content 11.5 Acknowledgements 11.6 Exercises", " Chapter 11 Local variation in GC content - NOT UPDATED By: Avril Coghlan. Adapted and edited by Nathan Brouwer. TODO need fasta clean function put into biodata Preliminaries library(rentrez) library(seqinr) 11.0.1 Note on the biology in this section Some of the biology in this tutorial appears to be out of date. For example, using variation in GC content to ID horizontal gene transfer is currently considered to be biased. The examples are still good for practicing R skills. 11.1 Vocabulary GC content horizontal transfer local variation in GC content … 11.2 Reading sequence data with rentrez::entrez_fetch In a previous section you learned how to use to search for and download the sequence data for a given NCBI accession from the NCBI Sequence Database, either via the NCBI website using entrez_fetch() from the rentrez package. For example, you could have downloaded the sequence data for a the DEN-1 Dengue virus sequence (NCBI accession NC_001477), and stored it on a file on your computer (eg. “dengue_fasta.fasta”). dengueseq_fasta &lt;- entrez_fetch(db = &quot;nucleotide&quot;, id = &quot;NC_001477&quot;, rettype = &quot;fasta&quot;) As noted before, the file gets downloaded in FASTA format, which isn’t directly useable in R We can convert our FASTA object into a vector using the function fasta_cleaner() header. &lt;- &quot;&gt;NC_001477.1 Dengue virus 1, complete genome&quot; dengueseq_vector &lt;- fasta_cleaner(dengueseq_fasta) Once you have retrieved a sequence from the NCBI Sequence Database and stored it in a vector variable such as dengueseq_vector in the example above, it is possible to extract subsequence of the sequence by typing the name of the vector (eg. dengueseq_vector) followed by the square brackets containing the indices for those nucleotides. For example, to obtain nucleotides 452-535 of the DEN-1 Dengue virus genome, we can type: dengueseq_vector[452:535] 11.3 Local variation in GC content In a previous section, you learned that to find out the GC content of a genome sequence (percentage of nucleotides in a genome sequence that are Gs or Cs), you can use the GC() function in the SeqinR package. For example, to find the GC content of the DEN-1 Dengue virus sequence that we have stored in the vector dengueseq, we can type: GC(dengueseq_vector) The output of the GC() is the fraction of nucleotides in a sequence that are Gs or Cs, so to convert it to a percentage we need to multiply by 100. GC(dengueseq_vector)*100 Thus, the GC content of the DEN-1 Dengue virus genome is about 0.467 or 46.7%. Although the GC content of the whole DEN-1 Dengue virus genome sequence is about 46.7%, there is probably local variation in GC content within the genome. That is, some regions of the genome sequence may have GC contents quite a bit higher than 46.7%, while some regions of the genome sequence may have GC contents that are quite a big lower than 46.7%. Local fluctuations in GC content within the genome sequence can provide different interesting information, for example, they may reveal cases of horizontal transfer or reveal biases in mutation. If a chunk of DNA has moved by horizontal transfer from the genome of a species with low GC content to a species with high GC content, the chunk of horizontally transferred DNA could be detected as a region of unusually low GC content in the high-GC recipient genome. On the other hand, a region unusually low GC content in an otherwise high-GC content genome could also arise due to biases in mutation in that region of the genome, for example, if mutations from Gs/Cs to Ts/As are more common for some reason in that region of the genome than in the rest of the genome. 11.4 A sliding window analysis of GC content In order to study local variation in GC content within a genome sequence, we could calculate the GC content for small chunks of the genome sequence. The DEN-1 Dengue virus genome sequence is 10735 nucleotides long. To study variation in GC content within the genome sequence, we could calculate the GC content of chunks of the DEN-1 Dengue virus genome, for example, for each 2000-nucleotide chunk of the genome sequence: GC(dengueseq[1:2000]) # Calculate the GC content of nucleotides 1-2000 of the Dengue genome GC(dengueseq[2001:4000]) # Calculate the GC content of nucleotides 2001-4000 of the Dengue genome From the output of the above calculations, we see that the region of the DEN-1 Dengue virus genome from nucleotides 1-2000 has a GC content of 46.5%, while the region of the Dengue genome from nucleotides 2001-4000 has a GC content of about 45.3%. Thus, there seems to be some local variation in GC content within the Dengue genome sequence. Instead of typing in the commands above to tell R to calculate the GC content for each 2000-nucleotide chunk of the DEN-1 Dengue genome, we can use a for loop to carry out the same calculations, but by typing far fewer commands. That is, we can use a for loop to take each 2000-nucleotide chunk of the DEN-1 Dengue virus genome, and to calculate the GC content of each 2000-nucleotide chunk. Below we will explain the following for loop that has been written for this purpose: starts &lt;- seq(1, length(dengueseq)-2000, by = 2000) starts n &lt;- length(starts) # Find the length of the vector &quot;starts&quot; for (i in 1:n) { chunk &lt;- dengueseq[starts[i]:(starts[i]+1999)] chunkGC &lt;- GC(chunk) print (chunkGC) } The command “starts &lt;- seq(1, length(dengueseq)-2000, by = 2000)” stores the result of the seq() command in the vector starts, which contains the values 1, 2001, 4001, 6001, and 8001. We set the variable n to be equal to the number of elements in the vector starts, so it will be 5 here, since the vector starts contains the five elements 1, 2001, 4001, 6001 and 8001. The line “for (i in 1:n)” means that the counter i will take values of 1-5 in subsequent cycles of the for loop. The for loop above is spread over several lines. However, R will not execute the commands within the for loop until you have typed the final “}” at the end of the for loop and pressed “Return”. Each of the three commands within the for loop are carried out in each cycle of the loop. In the first cycle of the loop, i is 1, the vector variable chunk is used to store the region from nucleotides 1-2000 of the Dengue virus sequence, the GC content of that region is calculated and stored in the variable chunkGC, and the value of chunkGC is printed out. In the second cycle of the loop, i is 2, the vector variable chunk is used to store the region from nucleotides 2001-4000 of the Dengue virus sequence, the GC content of that region is calculated and stored in the variable chunkGC, and the value of chunkGC is printed out. The loop continues until the value of i is 5. In the fifth cycle through the loop, the value of i is 5, and so the GC content of the region from nucleotides 8001-10000 is printed out. Note that we stop the loop when we are looking at the region from nucleotides 8001-10000, instead of continuing to another cycle of the loop where the region under examiniation would be from nucleotides 10001-12000. The reason for this is because the length of the Dengue virus genome sequence is just 10735 nucleotides, so there is not a full 2000-nucleotide region from nucleotide 10001 to the end of the sequence at nucleotide 10735. The above analysis of local variation in GC content is what is known as a sliding window analysis of GC content. By calculating the GC content in each 2000-nucleotide chunk of the Dengue virus genome, you are effectively sliding a 2000-nucleotide window along the DNA sequence from start to end, and calculating the GC content in each non-overlapping window (chunk of DNA). Note that this sliding window analysis of GC content is a slightly simplified version of the method usually carried out by bioinformaticians. In this simplified version, we have calculated the GC content in non-overlapping windows along a DNA sequence. However, it is more usual to calculate GC content in overlapping windows along a sequence, although that makes the code slightly more complicated. A sliding window plot of GC content It is common to use the data generated from a sliding window analysis to create a sliding window plot of GC content. To create a sliding window plot of GC content, you plot the local GC content in each window of the genome, versus the nucleotide position of the start of each window. We can create a sliding window plot of GC content by typing: starts &lt;- seq(1, length(dengueseq)-2000, by = 2000) n &lt;- length(starts) # Find the length of the vector “starts” chunkGCs &lt;- numeric(n) # Make a vector of the same length as vector “starts”, but just containing zeroes for (i in 1:n) { chunk &lt;- dengueseq[starts[i]:(starts[i]+1999)] chunkGC &lt;- GC(chunk) print(chunkGC) chunkGCs[i] &lt;- chunkGC } plot(starts,chunkGCs,type=“b”,xlab=“Nucleotide start position”,ylab=“GC content”) image2 In the code above, the line “chunkGCs &lt;- numeric(n)” makes a new vector chunkGCs which has the same number of elements as the vector starts (5 elements here). This vector chunkGCs is then used within the for loop for storing the GC content of each chunk of DNA. After the loop, the vector starts can be plotted against the vector chunkGCs using the plot() function, to get a plot of GC content against nucleotide position in the genome sequence. This is a sliding window plot of GC content. You may want to use the code above to create sliding window plots of GC content of different species’ genomes, using different windowsizes. Therefore, it makes sense to write a function to do the sliding window plot, that can take the windowsize that the user wants to use and the sequence that the user wants to study as arguments (inputs): slidingwindowplot &lt;- function(windowsize, inputseq) { starts &lt;- seq(1, length(inputseq)-windowsize, by = windowsize) n &lt;- length(starts) # Find the length of the vector “starts” chunkGCs &lt;- numeric(n) # Make a vector of the same length as vector “starts”, but just containing zeroes for (i in 1:n) { chunk &lt;- inputseq[starts[i]:(starts[i]+windowsize-1)] chunkGC &lt;- GC(chunk) print(chunkGC) chunkGCs[i] &lt;- chunkGC } plot(starts,chunkGCs,type=“b”,xlab=“Nucleotide start position”,ylab=“GC content”) } This function will make a sliding window plot of GC content for a particular input sequence inputseq specified by the user, using a particular windowsize windowsize specified by the user. Once you have typed in this function once, you can use it again and again to make sliding window plots of GC contents for different input DNA sequences, with different windowsizes. For example, you could create two different sliding window plots of the DEN-1 Dengue virus genome sequence, using windowsizes of 3000 and 300 nucleotides, respectively: slidingwindowplot(3000, dengueseq) image3 slidingwindowplot(300, dengueseq) image4 Over-represented and under-represented DNA words In the previous chapter, you learned that the count() function in the SeqinR R package can calculate the frequency of all DNA words of a certain length in a DNA sequence. For example, if you want to know the frequency of all DNA words that are 2 nucleotides long in the Dengue virus genome sequence, you can type: count(dengueseq, 2) aa ac ag at ca cc cg ct ga gc gg gt ta tc tg tt 1108 720 890 708 901 523 261 555 976 500 787 507 440 497 832 529 It is interesting to identify DNA words that are two nucleotides long (“dinucleotides”, ie. “AT”, “AC”, etc.) that are over-represented or under-represented in a DNA sequence. If a particular DNA word is over-represented in a sequence, it means that it occurs many more times in the sequence than you would have expected by chance. Similarly, if a particular DNA word is under-represented in a sequence, it means it occurs far fewer times in the sequence than you would have expected. A statistic called ρ (Rho) is used to measure how over- or under-represented a particular DNA word is. For a 2-nucleotide (dinucleotide) DNA word ρ is calculated as: ρ(xy) = fxy/(fx*fy), where fxy and fx are the frequencies of the DNA words xy and x in the DNA sequence under study. For example, the value of ρ for the DNA word “TA” can be calculated as: ρ(TA) = fTA/(fT* fA), where fTA, fT and fA are the frequencies of the DNA words “TA”, “T” and “A” in the DNA sequence. The idea behind the ρ statistic is that, if a DNA sequence had a frequency fx of a 1-nucleotide DNA word x, and a frequency fy of a 1-nucleotide DNA word y, then we expect the frequency of the 2-nucleotide DNA word xy to be fx* fy. That is, the frequencies of the 2-nucleotide DNA words in a sequence are expected to be equal the products of the specific frequencies of the two nucleotides that compose them. If this were true, then ρ would be equal to 1. If we find that ρ is much greater than 1 for a particular 2-nucleotide word in a sequence, it indicates that that 2-nucleotide word is much more common in that sequence than expected (ie. it is over-represented). For example, say that your input sequence has only 5% Ts (ie. fT = 0.05). In a random DNA sequence with 5% Ts, you would expect to see the word “TT” very infrequently. In fact, we would only expect 0.05 * 0.05=0.0025 (0.25%) of 2-nucleotide words to be TTs (ie. we expect fTT = fT* fT). This is because Ts are rare, so they are expected to be adjacent to each other very infrequently if the few Ts are randomly scattered throughout the DNA. Therefore, if you see lots of TT 2-nucleotide words in your real input sequence (eg. fTT = 0.3, so ρ = 0.3/0.0025 = 120), you would suspect that natural selection has acted to increase the number of occurrences of the TT word in the sequence (presumably because it has some beneficial biological function). To find over-represented and under-represented DNA words that are 2 nucleotides long in the DEN-1 Dengue virus sequence, we can calculate the ρ statistic for each 2-nucleotide word in the sequence. For example, given the number of occurrences of the individual nucleotides A, C, G and T in the Dengue sequence, and the number of occurrences of the DNA word GC in the sequence (500, from above), we can calculate the value of ρ for the 2-nucleotide DNA word “GC”, using the formula ρ(GC) = fGC/(fG * fC), where fGC, fG and fC are the frequencies of the DNA words “GC”, “G” and “C” in the DNA sequence: count(dengueseq, 1) # Get the number of occurrences of 1-nucleotide DNA words a c g t 3426 2240 2770 2299 2770/(3426+2240+2770+2299) # Get fG [1] 0.2580345 2240/(3426+2240+2770+2299) # Get fC [1] 0.2086633 count(dengueseq, 2) # Get the number of occurrences of 2-nucleotide DNA words aa ac ag at ca cc cg ct ga gc gg gt ta tc tg tt 1108 720 890 708 901 523 261 555 976 500 787 507 440 497 832 529 500/(1108+720+890+708+901+523+261+555+976+500+787+507+440+497+832+529) # Get fGC [1] 0.04658096 0.04658096/(0.2580345*0.2086633) # Get rho(GC) [1] 0.8651364 We calculate a value of ρ(GC) of approximately 0.865. This means that the DNA word “GC” is about 0.865 times as common in the DEN-1 Dengue virus sequence than expected. That is, it seems to be slightly under-represented. Note that if the ratio of the observed to expected frequency of a particular DNA word is very low or very high, then we would suspect that there is a statistical under-representation or over-representation of that DNA word. However, to be sure that this over- or under-representation is statistically significant, we would need to do a statistical test. We will not deal with the topic of how to carry out the statistical test here. Summary In this chapter, you will have learned to use the following R functions: seq() for creating a sequence of numbers print() for printing out the value of a variable plot() for making a plot (eg. a scatterplot) numeric() for making a numeric vector of a particular length function() for making a function All of these functions belong to the standard installation of R. You also learned how to use for loops to carry out the same operation again and again, each time on different inputs. Links and Further Reading Some links are included here for further reading. For background reading on DNA sequence statistics, it is recommended to read Chapter 1 of Introduction to Computational Genomics: a case studies approach by Cristianini and Hahn (Cambridge University Press; www.computational-genomics.net/book/). For more in-depth information and more examples on using the SeqinR package for sequence analysis, look at the SeqinR documentation, http://pbil.univ-lyon1.fr/software/seqinr/doc.php?lang=eng. There is also a very nice chapter on “Analyzing Sequences”, which includes examples of using SeqinR for sequence analysis, in the book Applied statistics for bioinformatics using R by Krijnen (available online at cran.r-project.org/doc/contrib/Krijnen-IntroBioInfStatistics.pdf). For a more in-depth introduction to R, a good online tutorial is available on the “Kickstarting R” website, cran.r-project.org/doc/contrib/Lemon-kickstart. There is another nice (slightly more in-depth) tutorial to R available on the “Introduction to R” website, cran.r-project.org/doc/manuals/R-intro.html. Acknowledgements Thank you to Noel O’Boyle for helping in using Sphinx, http://sphinx.pocoo.org, to create this document, and github, https://github.com/, to store different versions of the document as I was writing it, and readthedocs, http://readthedocs.org/, to build and distribute this document. 11.5 Acknowledgements This is a modification of “DNA Sequence Statistics (1)” from Avril Coghlan’s A little book of R for bioinformatics.. Almost all of text and code was originally written by Dr. Coghlan and distributed under the Creative Commons 3.0 license. In “A little book…” Coghlan write “Many of the ideas for the examples and exercises for this chapter were inspired by the Matlab case studies on Haemophilus influenzae (www.computational-genomics.net/case_studies/haemophilus_demo.html) and Bacteriophage lambda (http://www.computational-genomics.net/case_studies/lambdaphage_demo.html) from the website that accompanies the book Introduction to Computational Genomics: a case studies approach by Cristianini and Hahn (Cambridge University Press; www.computational-genomics.net/book/).” 11.5.1 License The content in this book is licensed under a Creative Commons Attribution 3.0 License. 11.6 Exercises Answer the following questions, using the R package. For each question, please record your answer, and what you typed into R to get this answer. Model answers to the exercises are given in Answers to the exercises on DNA Sequence Statistics (2). Draw a sliding window plot of GC content in the DEN-1 Dengue virus genome, using a window size of 200 nucleotides. Do you see any regions of unusual DNA content in the genome (eg. a high peak or low trough)? Make a sketch of each plot that you draw. At what position (in base-pairs) in the genome is there the largest change in local GC content (approximate position is fine here)? Compare the sliding window plots of GC content created using window sizes of 200 and 2000 nucleotides. How does window size affect your ability to detect differences within the Dengue virus genome? Draw a sliding window plot of GC content in the genome sequence for the bacterium Mycobacterium leprae strain TN (accession NC_002677) using a window size of 20000 nucleotides. Do you see any regions of unusual DNA content in the genome (eg. a high peak or low trough)? Make a sketch of each plot that you drew for the previous quetion. Write down the approximate nucleotide position of the highest peak or lowest trough that you see. Why do you think a window size of 20000 nucleotides was chosen? What do you see if you use a much smaller windowsize (eg. 200 nucleotides) or a much larger windowsize (eg. 200,000 nucleotides)? Advanced: Write a function to calculate the AT content of a DNA sequence (ie. the fraction of the nucleotides in the sequence that are As or Ts). What is the AT content of the Mycobacterium leprae TN genome? Hint: use the function count() to make a table containing the number of As, Gs, Ts and Cs in the sequence. Remember that function count() produces a table object, and you can access the elements of a table object using double square brackets. Do you notice a relationship between the AT content of the Mycobacterium leprae TN genome, and its GC content? Advanced: Write a function to draw a sliding window plot of AT content. Use it to make a sliding window plot of AT content along the Mycobacterium leprae TN genome, using a windowsize of 20000 nucleotides. Do you notice any relationship between the sliding window plot of GC content along the Mycobacterium leprae genome, and the sliding window plot of AT content? Make a sketch of the plot that you draw. Is the 3-nucleotide word GAC GC over-represented or under-represented in the Mycobacterium leprae TN genome sequence? What is the frequency of this word in the sequence? What is the expected frequency of this word in the sequence? What is the p (Rho) value for this word? How would you figure out whether there is already an R function to calculate p (Rho)? Is there one that you could use? "],["alignments-in-r-not-updayed.html", "Chapter 12 Alignments in R - NOT UPDAYED 12.1 Retrieving a UniProt protein sequence using SeqinR 12.2 Comparing two sequences using a dotplot 12.3 Aligning UniProt sequences", " Chapter 12 Alignments in R - NOT UPDAYED By: Avril Coghlan. Adapted and edited by Nathan Brouwer. 12.1 Retrieving a UniProt protein sequence using SeqinR An alternative method of retrieving a UniProt protein sequence is to use the SeqinR package to query the ACNUC sub-database “swissprot”, which contains protein sequences from UniProt. We use the query() function from SeqinR to query this database, as described in chapter3. For example to retrieve the protein sequences for UniProt accessions Q9CD83 and A0PQ23, we type in R: library(&quot;seqinr&quot;) choosebank(&quot;swissprot&quot;) query(&quot;leprae&quot;, &quot;AC=Q9CD83&quot;) lepraeseq &lt;- getSequence(leprae$req[[1]]) query(&quot;ulcerans&quot;, &quot;AC=A0PQ23&quot;) ulceransseq &lt;- getSequence(ulcerans$req[[1]]) closebank() Display the contents of “lepraeseq” lepraeseq 12.2 Comparing two sequences using a dotplot As a first step in comparing two protein, RNA or DNA sequences, it is a good idea to make a dotplot. A dotplot is a graphical method that allows the comparison of two protein or DNA sequences and identify regions of close similarity between them. A dotplot is essentially a two-dimensional matrix (like a grid), which has the sequences of the proteins being compared along the vertical and horizontal axes. In order to make a simple dotplot to represent of the similarity between two sequences, individual cells in the matrix can be shaded black if residues are identical, so that matching sequence segments appear as runs of diagonal lines across the matrix. Identical proteins will have a line exactly on the main diagonal of the dotplot, that spans across the whole matrix. For proteins that are not identical, but share regions of similarity, the dotplot will have shorter lines that may be on the main diagonal, or off the main diagonal of the matrix. In essence, a dotplot will reveal if there are any regions that are clearly very similar in two protein (or DNA) sequences. We can create a dotplot for two sequences using the “dotPlot()” function in the SeqinR R package. For example, if we want to create a dotplot of the sequences for the chorismate lyase proteins from Mycobacterium leprae and Mycobacterium ulcerans, we would type: dotPlot(lepraeseq, ulceransseq) image5 In the dotplot above, the M. leprae sequence is plotted along the x-axis (horizontal axis), and the M. ulcerans sequence is plotted along the y-axis (vertical axis). The dotplot displays a dot at points where there is an identical amino acid in the two sequences. For example, if amino acid 53 in the M. leprae sequence is the same amino acid (eg. “W”) as amino acid 70 in the M. ulcerans sequence, then the dotplot will show a dot the position in the plot where x =50 and y =53. In this case you can see a lot of dots along a diagonal line, which indicates that the two protein sequences contain many identical amino acids at the same (or very similar) positions along their lengths. This is what you would expect, because we know that these two proteins are homologues (related proteins). Pairwise global alignment of DNA sequences using the Needleman-Wunsch algorithm If you are studying a particular pair of genes or proteins, an important question is to what extent the two sequences are similar. To quantify similarity, it is necessary to align the two sequences, and then you can calculate a similarity score based on the alignment. There are two types of alignment in general. A global alignment is an alignment of the full length of two sequences, for example, of two protein sequences or of two DNA sequences. A local alignment is an alignment of part of one sequence to part of another sequence. The first step in computing a alignment (global or local) is to decide on a scoring system. For example, we may decide to give a score of +2 to a match and a penalty of -1 to a mismatch, and a penalty of -2 to a gap. Thus, for the alignment: G A A T T C G A T T - A we would compute a score of 2 + 2 -1 + 2 -2 - 1 = 2. Similarly, the score for the following alignment is 2 + 2 -2 + 2 + 2 -1 = 5: G A A T T C G A - T T A The scoring system above can be represented by a scoring matrix (also known as a substitution matrix). The scoring matrix has one row and one column for each possible letter in our alphabet of letters (eg. 4 rows and 4 columns for DNA sequences). The (i,j) element of the matrix has a value of +2 in case of a match and -1 in case of a mismatch. We can make a scoring matrix in R by using the nucleotideSubstitutionMatrix() function in the Biostrings() package. The Biostrings package is part of a set of R packages for bioinformatics analysis known as Bioconductor (www.bioconductor.org/). To use the Biostrings package, you will first need to install the package (see the instructions here). The arguments (inputs) for the nucleotideSubstitutionMatrix() function are the score that we want to assign to a match and the score that we want to assign to a mismatch. We can also specify that we want to use only the four letters representing the four nucleotides (ie. A, C, G, T) by setting ‘baseOnly=TRUE’, or whether we also want to use the letters that represent ambiguous cases where we are not sure what the nucleotide is (eg. ‘N’ = A/C/G/T). To make a scoring matrix which assigns a score of +2 to a match and -1 to a mismatch, and store it in the variable sigma, we type: dotPlot(lepraeseq, ulceransseq) Instead of assigning the same penalty (eg. -8) to every gap position, it is common instead to assign a gap opening penalty to the first position in a gap (eg. -8), and a smaller gap extension penalty to every subsequent position in the same gap. The reason for doing this is that it is likely that adjacent gap positions were created by the same insertion or deletion event, rather than by several independent insertion or deletion events. Therefore, we don’t want to penalise a 3-letter gap as much as we would penalise three separate 1-letter gaps, as the 3-letter gap may have arisen due to just one insertion or deletion event, while the 3 separate 1-letter gaps probably arose due to three independent insertion or deletion events. For example, if we want to compute the score for a global alignment of two short DNA sequences ‘GAATTC’ and ‘GATTA’, we can use the Needleman-Wunsch algorithm to calculate the highest-scoring alignment using a particular scoring function. The “pairwiseAlignment()” function in the Biostrings R package finds the score for the optimal global alignment between two sequences using the Needleman-Wunsch algorithm, given a particular scoring system. As arguments (inputs), the pairwiseAlignment() function takes the two sequences that you want to align, the scoring matrix, the gap opening penalty, and the gap extension penalty. You can also tell the function that you want to just have the optimal global alignment’s score by setting “scoreOnly = TRUE”, or that you want to have both the optimal global alignment and its score by setting “scoreOnly = FALSE”. For example, to find the score for the optimal global alignment between the sequences ‘GAATTC’ and ‘GATTA’, we type: s1 &lt;- &quot;GAATTC&quot; s2 &lt;- &quot;GATTA&quot; globalAligns1s2 &lt;- pairwiseAlignment(s1, s2, substitutionMatrix = sigma, gapOpening = -2, gapExtension = -8, scoreOnly = FALSE) globalAligns1s2 # Print out the optimal alignment and its score The above commands print out the optimal global alignment for the two sequences and its score. Note that we set “gapOpening” to be -2 and “gapExtension” to be -8, which means that the first position of a gap is assigned a score of (-8-2=)-10, and every subsequent position in a gap is given a score of -8. Here the alignment contains four matches, one mismatch, and one gap of length 1, so its score is (42)+(1-1)+(1*-10) = -3. Pairwise global alignment of protein sequences using the Needleman-Wunsch algorithm As well as DNA alignments, it is also possible to make alignments of protein sequences. In this case it is necessary to use a scoring matrix for amino acids rather than for nucleotides. There are several well known scoring matrices that come with R, such as the BLOSUM series of matrices. Different BLOSUM matrices exist, named with different numbers. BLOSUM with high numbers are designed for comparing closely related sequences, while BLOSUM with low numbers are designed for comparing distantly related sequences. For example, BLOSUM62 is used for less divergent alignments (alignments of sequences that differ little), and BLOSUM30 is used for more divergent alignments (alignments of sequences that differ a lot). Many R packages come with example data sets or data files. The “data()” function is used to load these data files. You can use the data() function in R to load a data set of BLOSUM matrices that comes with R Biostrings() package. To load the BLOSUM50 matrix, we type: data(BLOSUM50) BLOSUM50 # Print out the data You can get a list of the available scoring matrices that come with the Biostrings package by using the data() function, which takes as an argument the name of the package for which you want to know the data sets that come with it: data(package=&quot;Biostrings&quot;) To find the optimal global alignment between the protein sequences “PAWHEAE” and “HEAGAWGHEE” using the Needleman-Wunsch algorithm using the BLOSUM50 matrix, we type: data(BLOSUM50) s3 &lt;- &quot;PAWHEAE&quot; s4 &lt;- &quot;HEAGAWGHEE&quot; globalAligns3s4 &lt;- pairwiseAlignment(s3, s4, substitutionMatrix = &quot;BLOSUM50&quot;, gapOpening = -2, gapExtension = -8, scoreOnly = FALSE) globalAligns3s4 # Print out the optimal global alignment and its score We set “gapOpening” to be -2 and “gapExtension” to be -8, which means that the first position of a gap is assigned a score of (-8-2=)-10, and every subsequent position in a gap is given a score of -8. This means that the gap will be given a score of -10-8-8 = -26. 12.3 Aligning UniProt sequences We discussed above how you can search for UniProt accessions and retrieve the corresponding protein sequences, either via the UniProt website or using the SeqinR R package. In the examples given above, you learned how to retrieve the sequences for the chorismate lyase proteins from Mycobacterium leprae (UniProt Q9CD83) and Mycobacterium ulcerans (UniProt A0PQ23), and read them into R, and store them as vectors lepraeseq and ulceransseq. You can align these sequences using pairwiseAlignment() from the Biostrings package. As its input, the pairwiseAlignment() function requires that the sequences be in the form of a single string (eg. “ACGTA”), rather than as a vector of characters (eg. a vector with the first element as “A”, the second element as “C”, etc.). Therefore, to align the M. leprae and M. ulcerans chorismate lyase proteins, we first need to convert the vectors lepraeeq and ulceransseq into strings. We can do this using the c2s() function in the SeqinR package: lepraeseqstring &lt;- c2s(lepraeseq) # Make a string that contains the sequence in &quot;lepraeseq&quot; ulceransseqstring &lt;- c2s(ulceransseq) # Make a string that contains the sequence in &quot;ulceransseq&quot; Furthermore, pairwiseAlignment() requires that the sequences be stored as uppercase characters. Therefore, if they are not already in uppercase, we need to use the toupper() function to convert lepraeseqstring and ulceransseqstring to uppercase: lepraeseqstring &lt;- toupper(lepraeseqstring) ulceransseqstring &lt;- toupper(ulceransseqstring) lepraeseqstring # Print out the content of &quot;lepraeseqstring&quot; We can now align the the M. leprae and M. ulcerans chorismate lyase protein sequences using the pairwiseAlignment() function: globalAlignLepraeUlcerans &lt;- pairwiseAlignment(lepraeseqstring, ulceransseqstring, substitutionMatrix = BLOSUM50, gapOpening = -2, gapExtension = -8, scoreOnly = FALSE) globalAlignLepraeUlcerans # Print out the optimal global alignment and its score As the alignment is very long, when you type globalAlignLepraeUlcerans, you only see the start and the end of the alignment (see above). Therefore, we need to have a function to print out the whole alignment (see below). Viewing a long pairwise alignment If you want to view a long pairwise alignment such as that between the M. leprae and M. ulerans chorismate lyase proteins, it is convenient to print out the alignment in blocks. The R function “printPairwiseAlignment()” below will do this for you: To use this function you first need to copy and paste this function into R. You can then use our function printPairwiseAlignment() to print out the alignment between the M. leprae and M. ulcerans chorismate lyase proteins (we stored this alignment in the globalAlignLepraeUlcerans variable, see above), in blocks of 60 alignment columns: printPairwiseAlignment(globalAlignLepraeUlcerans, 60) The position in the protein of the amino acid that is at the end of each line of the printed alignment is shown after the end of the line. For example, the first line of the alignment above finishes at amino acid position 50 in the M. leprae protein and also at amino acid position 60 in the M. ulcerans protein. Since we are printing out an alignment that contained gaps in the first 60 alignment columns, the first 60 alignment columns ends before the 60th amino acid in the M. leprae sequence. Pairwise local alignment of protein sequences using the Smith-Waterman algorithm You can use the pairwiseAlignment() function to find the optimal local alignment of two sequences, that is the best alignment of parts (subsequences) of those sequences, by using the “type=local” argument in pairwiseAlignment(). This uses the Smith-Waterman algorithm for local alignment, the classic bioinformatics algorithm for finding optimal local alignments. For example, to find the best local alignment between the M. leprae and M. ulcerans chorismate lyase proteins, we can type: localAlignLepraeUlcerans &lt;- pairwiseAlignment(lepraeseqstring, ulceransseqstring, substitutionMatrix = BLOSUM50, gapOpening = -2, gapExtension = -8, scoreOnly = FALSE, type=&quot;local&quot;) Print out the optimal local alignment and its score localAlignLepraeUlcerans printPairwiseAlignment(localAlignLepraeUlcerans, 60) We see that the optimal local alignment is quite similar to the optimal global alignment in this case, except that it excludes a short region of poorly aligned sequence at the start and at the ends of the two proteins. "],["multiple-alignment-with-clustal.html", "Chapter 13 Multiple alignment with Clustal 13.1 Installing the CLUSTAL multiple alignment software 13.2 Discarding very poorly conserved regions from an alignment 13.3 Calculating genetic distances between protein sequences", " Chapter 13 Multiple alignment with Clustal By: Avril Coghlan. Adapted and edited by Nathan Brouwer. 13.1 Installing the CLUSTAL multiple alignment software A common task in bioinformatics is to download a set of related sequences from a database, and then to align those sequences using multiple alignment software. This is the first step in most phylogenetic analyses. One commonly used multiple alignment software package is CLUSTAL. In order to build an alignment using CLUSTAL, you first need to install the CLUSTAL program on your computer. To install CLUSTAL on your computer, you need to follow these steps: Go to the http://www.clustal.org/download/current/ website. Right-click on the link to file clustalx-Z.Z.Z-win.msi (where Z represents some number) and choose “Save link as…” and then save the file in your “My Documents” folder. Once the file has downloaded, double-click on the icon for file clustalx-Z.Z.Z-win.msi (where Z is some number). You will be asked “Are you sure you want to run this software?” Press “Run”. You will then see “Welcome to the ClustalX2 setup wizard”. Press “Next”. You will be asked where to install ClustalX2. Select your “My Documents” folder. Keep pressing ‘yes’ or ‘Next’ until the screen says “Completing the ClustalX2 setup wizard”. Then press “Finish”. CLUSTAL should now be installed on your computer. Creating a multiple alignment of protein, DNA or mRNA sequences using CLUSTAL Once you have installed CLUSTAL, you can now align your sequences using CLUSTAL by following these steps: Go to the “Start” menu on the bottom left of your Windows screen. Select “All Programs” from the menu, then select “ClustalX2” from the menu that appears. This will start up CLUSTAL. The CLUSTAL window should appear. To load the DNA or protein sequences that you want to align into CLUSTAL, go to the CLUSTAL “File” menu, and choose “Load sequences”. Select the FASTA-format file containing your sequences (eg. phosphoproteins.fasta) to load it into CLUSTAL. This should read the sequences into CLUSTAL. They have not been aligned yet, but will be displayed in the CLUSTAL window. You can use the scrollbar on the right to scroll down and look at all the sequences. You can use the scrollbar on the bottom to scroll from left to right, and look along the length of the sequences. Before you align the sequences using CLUSTAL, you need to tell CLUSTAL to make the output alignment file in PHYLIP alignment format, so that you can read it into R. To do this, go to the “Alignment” menu in CLUSTAL, choose “Output Format Options”. A form will appear, and in this form you should select “PHYLIP format” and deselect “CLUSTAL format”, and then press “OK”. To now align the sequences using CLUSTAL, go to the CLUSTAL “Alignment” menu, and choose “Do Complete Alignment”. A menu box will pop up, asking you where to save the output guide-tree file (eg. “phosphoproteins.dnd”) and the output alignment file (called “phosphoproteins.phy”). You should choose to save them in your “My Documents” folder (so that you can easily read them into R from “My Documents” at a later stage). CLUSTAL will now align the sequences. This will take a couple of minutes (eg. 2-5 minutes). You will see that at the bottom of the CLUSTAL window, it tells you which pair of sequences it is aligning at a particular point in time. If the numbers keep changing, it means that CLUSTAL is still working away, and the alignment is not finished yet. Be patient! Once CLUSTAL has finished making the alignment, it will be displayed in the CLUSTAL window. For example, here is the CLUSTAL alignment for rabies virus phosphoprotein, Mokola virus phosphoprotein, and Lagos bat virus phosphoprotein: The alignment displayed in CLUSTAL has a row for each of your sequences. CLUSTAL colours sets of chemically similar amino acids in similar colours. For example, tyrosine (Y) is coloured blue-green, while the chemically similar amino acid phenylalanine (F) is coloured blue. You can scroll to the right and left along the alignment using the scrollbar at the bottom of the Jalview window. Below the alignment, you can see a grey plot, showing the level of conservation at each point of the sequence. This shows a high grey bar if the conservation in a region is high (there is high percent identity between the sequence), and a low grey bar if it is low (there is low percent identity). This can give you an idea of which are the best conserved regions of the alginment. For example, for the alignment of the four virus phosphoproteins, we can see that the region in alignment columns 35 to 45 approximately is very well conserved, while the region in alignment columns 60 to 70 is poorly conserved. The CLUSTAL alignment will have been saved in a file in your “My Documents” folder called “something.phy” (eg. phosphoproteins.phy). This is a PHYLIP-format alignment file, which you can now read into R for further analysis. Reading a multiple alignment file into R To read a sequence alignment into R from a file, you can use the read.alignment() function in the SeqinR package. For example, to read in the multiple sequence alignment of the virus phosphoproteins into R, we type: virusaln &lt;- read.alignment(file = &quot;phosphoproteins.phy&quot;, format = &quot;phylip&quot;) The virusaln variable is a list variable that stores the alignment. An R list variable can have named elements, and you can access the named elements of a list variable by typing the variable name, followed by “$”, followed by the name of the named element. The list variable virusaln has named elements “nb”, “nam”, “seq”, and “com”. In fact, the named element “seq” contains the alignment, which you can view by typing: virusaln$seq Only the first part of the alignment stored in virusaln$seq is shown here, as it is very long. Viewing a long multiple alignment If you want to view a long multiple alignment, it is convenient to view the multiple alignment in blocks. The R function “printMultipleAlignment()” below will do this for you:N As its inputs, the function “printMultipleAlignment()” takes the input alignment, and the number of columns to print out in each block. For example, to print out the multiple alignment of virus phosphoproteins (which we stored in variable virusaln, see above) in blocks of 60 columns, we type: printMultipleAlignment(virusaln, 60) 13.2 Discarding very poorly conserved regions from an alignment It is often a good idea to discard very poorly conserved regions from a mulitple alignment before building a phylogenetic tree, as the very poorly conserved regions are likely to be regions that are either not homologous between the sequences being considered (and so do not add any phylogenetic signal), or are homologous but are so diverged that they are very difficult to align accurately (and so may add noise to the phylogenetic analysis, and decrease the accuracy of the inferred tree). To discard very poorly conserved regions from a multiple alignment, you can use the following R function, “cleanAlignment()”: The function cleanAlignment() takes three arguments (inputs): the input alignment; the minimum percent of letters in an alignment column that must be non-gap characters for the column to be kept; and the minimum percent of pairs of letters in an alignment column that must be identical for the column to be kept. For example, if we have a column with letters “T”, “A”, “T”, “-” (in four sequences), then 75% of the letters are non-gap characters; and the pairs of letters are “T,A”, “T,T”, and “A,T”, and 33% of the pairs of letters are identical. We can use the function cleanAlignment() to discard the very poorly aligned columns from a multiple alignment. For example, if you look at the multiple alignment for the virus phosphoprotein sequences (which we printed out using function printMultipleAlignment(), see above), we can see that the last few columns are poorly aligned (contain many gaps and mismatches), and probably add noise to the phylogenetic analysis. Therefore, to filter out the well conserved columns of the alignment, and discard the very poorly conserved columns, we can type: cleanedvirusaln &lt;- cleanAlignment(virusaln, 30, 30) In this case, we required that at least 30% of letters in a column are not gap characters for that column to be kept, and that at least 30% of pairs of letters in an alignment column must be identical for the column to be kept. We can print out the filtered alignment by typing: printMultipleAlignment(cleanedvirusaln) The filtered alignment is shorter, but is missing some of the poorly conserved regions of the original alignment. Note that it is not a good idea to filter out too much of your alignment, as if you are left with few columns in your filtered alignment, you will be basing your phylogenetic tree upon a very short alignment (little data), and so the tree may be unreliable. Therefore, you need to achieve a balance between discarding the dodgy (poorly aligned) parts of your alignment, and retaining enough columns of the alignment that you will have enough data to based your tree upon. 13.3 Calculating genetic distances between protein sequences A common first step in performing a phylogenetic analysis is to calculate the pairwise genetic distances between sequences. The genetic distance is an estimate of the divergence between two sequences, and is usually measured in quantity of evolutionary change (an estimate of the number of mutations that have occurred since the two sequences shared a common ancestor). We can calculate the genetic distances between protein sequences using the “dist.alignment()” function in the SeqinR package. The dist.alignment() function takes a multiple alignment as input. Based on the multiple alignment that you give it, dist.alignment() calculates the genetic distance between each pair of proteins in the multiple alignment. For example, to calculate genetic distances between the virus phosphoproteins based on the multiple sequence alignment stored in virusaln, we type: virusdist &lt;- dist.alignment(virusaln) # Calculate the genetic distances Print out the genetic distance virusdist The genetic distance matrix above shows the genetic distance between each pair of proteins. The sequences are referred to by their UniProt accessions. If you remember from above, P06747 is rabies virus phosphoprotein, P0C569 is Mokola virus phosphoprotein, O56773 is Lagos bat virus phosphoprotein and Q5VKP1 is Western Caucasian bat virus phosphoprotein. Based on the genetic distance matrix above, we can see that the genetic distance between Lagos bat virus phosphoprotein (O56773) and Mokola virus phosphoprotein (P0C569) is smallest (about 0.414). Similarly, the genetic distance between Western Caucasian bat virus phosphoprotein (Q5VKP1) and Lagos bat virus phosphoprotein (O56773) is the biggest (about 0.507). The larger the genetic distance between two sequences, the more amino acid changes or indels that have occurred since they shared a common ancestor, and the longer ago their common ancestor probably lived. Calculating genetic distances between DNA/mRNA sequences Just like for protein sequences, you can calculate genetic distances between DNA (or mRNA) sequences based on an alignment of the sequences. For example, the NCBI accession AF049118 contains mRNA sequence for Mokola virus phosphoprotein, RefSeq AF049114 contains mRNA sequence for Mokola virus phosphoprotein, and AF049119 contains the mRNA sequence for Lagos bat virus phosphoprotein, while AF049115 contains the mRNA sequence for Duvenhage virus phosphoprotein. To retrieve these sequences from the NCBI database, we can search the ACNUC “genbank” sub-database (since these are nucleotide sequences), by typing: Make a vector containing the names of the sequences seqnames &lt;- c(&quot;AF049118&quot;, &quot;AF049114&quot;, &quot;AF049119&quot;, &quot;AF049115&quot;) # Retrieve the sequences and store them in list variable “seqs” seqs &lt;- retrieveseqs(seqnames,&quot;genbank&quot;) # We can then write out the sequences to a FASTA-format file by typing: write.fasta(seqs, seqnames, file=&quot;virusmRNA.fasta&quot;) We can then use CLUSTAL to create a PHYLIP-format alignment of the sequences, and store it in the alignment file “virusmRNA.phy”. This picture shows part of the alignment: We can then read the alignment into R: virusmRNAaln &lt;- read.alignment(file = &quot;virusmRNA.phy&quot;, format = &quot;phylip&quot;) We saw above that the function dist.alignment() can be used to calculate a genetic distance matrix based on a protein sequence alignment. You can calculate a genetic distance for DNA or mRNA sequences using the dist.dna() function in the Ape R package. dist.dna() takes a multiple alignment of DNA or mRNA sequences as its input, and calculates the genetic distance between each pair of DNA sequences in the multiple alignment. The dist.dna() function requires the input alignment to be in a special format known as “DNAbin” format, so we must use the as.DNAbin() function to convert our DNA alignment into this format before using the dist.dna() function. For example, to calculate the genetic distance between each pair of mRNA sequences for the virus phosphoproteins, we type: Convert the alignment to “DNAbin” format virusmRNAalnbin &lt;- as.DNAbin(virusmRNAaln) Calculate the genetic distance matrix virusmRNAdist &lt;- dist.dna(virusmRNAalnbin) Print out the genetic distance matrix virusmRNAdist "],["unrooted-neighbor-joining-phylogenetic-trees.html", "Chapter 14 Unrooted Neighbor-joining Phylogenetic trees 14.1 Building an unrooted phylogenetic tree for protein sequences 14.2 Testing the significance of an alignment 14.3 Calculating the statistical significance of a pairwise global alignment 14.4 Summary", " Chapter 14 Unrooted Neighbor-joining Phylogenetic trees By: Avril Coghlan. Adapted and edited by Nathan Brouwer. 14.1 Building an unrooted phylogenetic tree for protein sequences Once we have a distance matrix that gives the pairwise distances between all our protein sequences, we can build a phylogenetic tree based on that distance matrix. One method for using this is the neighbour-joining algorithm. You can build a phylogenetic tree using the neighbour-joining algorithm with the the Ape R package. First you will need to install the “ape” package (see instructions on how to install R packages). The following R function “unrootedNJtree()” builds a phylogenetic tree based on an alignment of sequences, using the neighbour-joining algorithm, using functions from the “ape” package. The “unrootedNJtree()” function takes an alignment of sequences its input, calculates pairwise distances between the sequences based on the alignment, and then builds a phylogenetic tree based on the pairwise distances. It returns the phylogenetic tree, and also makes a picture of that tree: To use the function to make a phylogenetic tree, you must first copy and paste the function into R. You can then use it to make a tree, for example of the virus phosphoproteins, based on the sequence alignment: virusalntree &lt;- unrootedNJtree(virusaln,type=&quot;protein&quot;) Note that you need to specify that the type of sequences that you are using are protein sequences when you use unrootedNJtree(), by setting “type=protein”. We can see that Q5VKP1 (Western Caucasian bat virus phosphoprotein) and P06747 (rabies virus phosphoprotein) have been grouped together in the tree, and that O56773 (Lagos bat virus phosphoprotein) and P0C569 (Mokola virus phosphoprotein) are grouped together in the tree. This is consistent with what we saw above in the genetic distance matrix, which showed that the genetic distance between Lagos bat virus phosphoprotein (O56773) and Mokola virus phosphoprotein (P0C569) is relatively small. The numbers in blue boxes are bootstrap values for the nodes in the tree. A bootstrap value for a particular node in the tree gives an idea of the confidence that we have in the clade (group) defined by that node in the tree. If a node has a high bootstrap value (near 100%) then we are very confident that the clade defined by the node is correct, while if it has a low bootstrap value (near 0%) then we are not so confident. Note that the fact that a bootstrap value for a node is high does not necessarily guarantee that the clade defined by the node is correct, but just tells us that it is quite likely that it is correct. The bootstrap values are calculated by making many (for example, 100) random “resamples” of the alignment that the phylogenetic tree was based upon. Each “resample” of the alignment consists of a certain number x (eg. 200) of randomly sampled columns from the alignment. Each “resample” of the alignment (eg. 200 randomly sampled columns) forms a sort of fake alignment of its own, and a phylogenetic tree can be based upon the “resample”. We can make 100 random resamples of the alignment, and build 100 phylogenetic trees based on the 100 resamples. These 100 trees are known as the “bootstrap trees”. For each clade (grouping) that we see in our original phylogenetic tree, we can count in how many of the 100 bootstrap trees it appears. This is known as the “bootstrap value” for the clade in our original phylogenetic tree. For example, if we calculate 100 random resamples of the virus phosphoprotein alignment, and build 100 phylogenetic trees based on these resamples, we can calculate the bootstrap values for each clade in the virus phosphoprotein phylogenetic tree. In this case, the bootstrap value for the node defining the clade containing Q5VKP1 (Western Caucasian bat virus phosphoprotein) and P06747 (rabies virus phosphoprotein) is 25%, while the bootstrap value for node defining the clade containg of Lagos bat virus phosphoprotein (O56773) and Mokola virus phosphoprotein (P0C569) is 100%. The bootstrap values for each of these clades is the percent of 100 bootstrap trees that the clade appears in. Therefore, we are very confident that Lagos bat virus and Mokola virus phosphoproteins should be grouped together in the tree. However, we are not so confident that the Western Caucasian bat virus and rabies virus phosphoproteins should be grouped together. The lengths of the branches in the plot of the tree are proportional to the amount of evolutionary change (estimated number of mutations) along the branches. In this case, the branches leading to Lagos bat virus phosphoprotein (O56773) and Mokola virus phosphoprotein (P0C569) from the node representing their common ancestor are slightly shorter than the branches leading to the Western Caucasian bat virus (Q5VKP1) and rabies virus (P06747) phosphoproteins from the node representing their common ancestor. This suggests that there might have been more mutations in the Western Caucasian bat virus (Q5VKP1) and rabies virus (P06747) phosphoproteins since they shared a common ancestor, than in the Lagos bat virus phosphoprotein (O56773) and Mokola virus phosphoprotein (P0C569) since they shared a common ancestor. The tree above of the virus phosphoproteins is an unrooted phylogenetic tree as it does not contain an outgroup sequence, that is a sequence of a protein that is known to be more distantly related to the other proteins in the tree than they are to each other. As a result, we cannot tell which direction evolutionary time ran in along the internal branches of the tree. For example, we cannot tell whether the node representing the common ancestor of (O56773, P0C569) was an ancestor of the node representing the common ancestor of (Q5VKP1, P06747), or the other way around. In order to build a rooted phylogenetic tree, we need to have an outgroup sequence in our tree. In the case of the virus phosphoproteins, this is unfortunately not possible, as (as far as I know) there is not any protein known that is more distantly related to the four proteins already in our tree than they are to each other. However, in many other cases, an outgroup - a sequence known to be more distantly relatd to the other sequences in the tree than they are to each other - is known, and so it is possible to build a rooted phylogenetic tree. We discussed above that it is a good idea to investigate whether discarding the poorly conserved regions of a multiple alignment has an effect on the phylogenetic analysis. In this case, we made a filtered copy of the multiple alignment and stored it in the variable cleanedvirusaln (see above). We can make a phylogenetic tree based this filtered alignment, and see if it agrees with the phylogenetic tree based on the original alignment: cleanedvirusalntree &lt;- unrootedNJtree(cleanedvirusaln,type=&quot;protein&quot;) Here O56773 and P0C569 are grouped together, and Q5VKP1 and P06747 are grouped together, as in the phylogenetic tree based on the raw (unfiltered) multiple alignment (see above). Thus, filtering the multiple alignment does not have an effect on the tree. If we had found a difference in the trees made using the unfiltered and filtered multiple alignments, we would have to examine the multiple alignments closely, to see if the unfiltered multiple alignment contains a lot of very poorly aligned regions that might be adding noise to the phylogenetic analysis (if this is true, the tree based on the filtered alignment is likely to be more reliable). 14.2 Testing the significance of an alignment By: Avril Coghlan. Adapted and edited by Nathan Brouwer. 14.3 Calculating the statistical significance of a pairwise global alignment We have seen that when we align the ‘PAWHEAE’ and ‘HEAGAWGHEE’ protein sequences, they have some similarity, and the score for their optimal global alignment is -5. But is this alignment statistically significant? In other words, is this alignment better than we would expect between any two random proteins? The Needleman-Wunsch alignment algorithm will produce a global alignment even if we give it two unrelated random protein sequences, although the alignment score would be low. Therefore, we should ask: is the score for our alignment better than expected between two random sequences of the same lengths and amino acid compositions? It is reasonable to expect that if the alignment score is statistically significant, then it will be higher than the scores obtained from aligning pairs of random protein sequences that have the same lengths and amino acid compositions as our original two sequences. Therefore, to assess if the score for our alignment between the “PAWHEAE” and “HEAGAWGHEE” protein sequence is statistically significant, a first step is to make some random sequences that have the same amino acid composition and length as one of our initial two sequences, for example, as the same amino acid composition and length as the sequence ‘PAWHEAE’. How can we obtain random sequences of the same amino acid composition and length as the sequence ‘PAWHEAE’? One way is to generate sequences using a multinomial model for protein sequences in which the probabilities of the different amino acids set to be equal to their frequencies in the sequence ‘PAWHEAE’. That is, we can generate sequences using a multinomial model for proteins, in which the probability of “P” is set to 0.1428571 (1/7); the probability of “A” is set to 0.2857143 (2/7); the probability of “W” is set to 0.1428571 (1/7); the probability of \"H’ is set to 0.1428571 (1/7); and the probabilty of ‘E’ is set to 0.2857143 (2/7), and the probabilities of the other 15 amino acids are set to 0. To generate a sequence with this multinomial model, we choose the letter for each position in the sequence according to those probabilities. This is as if we have made a roulette wheel in which 1/7th of the circle is taken up by a pie labelled “P”, 2/7ths by a pie labelled “A”, 1/7th by a pie labelled “W”, 1/7th by a pie labelled “H”, and 2/7ths by a pie labelled “E”: image3 To generate a sequence using the multinomial model, we keep spinning the arrow in the centre of the roulette wheel, and write down the letter that the arrow stops on after each spin. To generate a sequence that is 7 letters long, we can spin the arrow 7 times. To generate 1000 sequences that are each 7 letters long, we can spin the arrow 7000 times, where the letters chosen form 1000 7-letter amino acid sequences. To generate a certain number (eg.1000) random amino acid sequences of a certain length using a multinomial model, you can use the function generateSeqsWithMultinomialModel() below: The function generateSeqsWithMultinomialModel() generates X random sequences with a multinomial model, where the probabilities of the different letters are set equal to their frequencies in an input sequence, which is passed to the function as a string of characters (eg. ‘PAWHEAE’). The function returns X random sequences in the form of a vector which has X elements, the first element of the vector contains the first sequence, the second element contains the second sequence, and so on. You will need to copy and paste this function into R before you can use it. We can use this function to generate 1000 7-letter amino acid sequences using a multinomial model in which the probabilities of the letters are set equal to their frequencies in ‘PAWHEAE’ (ie. probabilities 1/7 for P, 2/7 for A, 1/7 for W, 1/7 for H and 2/7 for E), by typing: randomseqs &lt;- generateSeqsWithMultinomialModel(&#39;PAWHEAE&#39;,1000) randomseqs[1:10] # Print out the first 10 random sequences The 1000 random sequences are stored in a vector randomseqs that has 1000 elements, each of which contains one of the random sequences. We can then use the Needleman-Wunsch algorithm to align the sequence ‘HEAGAWGHEE’ to one of the 1000 random sequences generated using the multinomial model with probabilities 1/7 for P, 2/7 for A, 1/7 for W, 1/7 for H and 2/7 for E. For example, to align ‘HEAGAWGHEE’ to the first of the 1000 random sequences (‘EEHAAAE’), we type: s4 &lt;- &quot;HEAGAWGHEE&quot; pairwiseAlignment(s4, randomseqs[1], substitutionMatrix = &quot;BLOSUM50&quot;, gapOpening = -2, gapExtension = -8, scoreOnly = FALSE) If we use the pairwiseAlignment() function with the argument ‘scoreOnly=TRUE’, it will just give us the score for the alignment: pairwiseAlignment(s4, randomseqs[1], substitutionMatrix = &quot;BLOSUM50&quot;, gapOpening = -2, gapExtension = -8, scoreOnly = TRUE) If we repeat this 1000 times, that is, for each of the 1000 random sequences in vector randomseqs, we can get a distribution of alignment scores expected for aligning ‘HEAGAWGHEE’ to random sequences of the same length and (approximately the same) amino acid composition as ‘PAWHEAE’. We can then compare the actual score for aligning ‘PAWHEAE’ to ‘HEAGAWGHEE’ (ie. -5) to the distribution of scores for aligning ‘HEAGAWGHEE’ to the random sequences. The code above first uses the double() function to create a numeric vector randomscores for storing real numbers (ie. not integers), with 1000 elements. This will be used to store the alignment scores for 1000 alignments between ‘HEAGAWGHEE’ and the 1000 different random sequences generated using the multinomial model. The ‘for loop’ takes each of the 1000 different random sequences, aligns each one to ‘HEAGAWGHEE’, and stores the 1000 alignment scores in the randomscores vector. Once we have run the ‘for loop’, we can make a histogram plot of the 1000 scores in vector randomscores by typing: hist(randomscores, col=&quot;red&quot;) # Draw a red histogram image4 We can see from the histogram that quite a lot of the random sequences seem to have higher alignment scores than -5 when aligned to ‘HEAGAWGHEE’ (where -5 is the alignment score for ‘PAWHEAE’ and ‘HEAGAWGHEE’). We can use the vector randomscores of scores for 1000 alignments of random sequences to ‘HEAGAWGHEE’ to calculate the probability of getting a score as large as the real alignment score for ‘PAWHEAE’ and ‘HEAGAWGHEE’ (ie. -5) by chance. sum(randomscores &gt;= -5) We see that 266 of the 1000 alignments of random sequences to ‘HEAGAWGHEE’ had alignment scores that were equal to or greater than -5. Thus, we can estimate that the probability of getting a score as large as the real alignment score by chance is (266/1000 =) 0.266. In other words, we can calculate a P-value of 0.266. This probability or P-value is quite high (almost 30%, or 1 in 3), so we can conclude that it is quite probable that we could get an alignment score as high as -5 by chance alone. This indicates that the sequences ‘HEAGAWGHEE’ and ‘PAWHEAE’ are not more similar than any two random sequences, and so they are probably not related sequences. Another way of saying this is that the P-value that we calculated is high (0.266), and as a result we conclude that the alignment score for the sequences ‘HEAGAWGHEE’ and ‘PAWHEAE’ is not statistically significant. Generally, if the P-value that we calculate for an alignment of two sequences is &gt;0.05, we conclude that the alignment score is not statistically significant, and that the sequences are probably not related. On the other hand, if the P-value is less than or equal to 0.05, we conclude that the alignment score is statistically significant, and the sequences are very probably related (homologous). 14.4 Summary In this practical, you will have learned to use the following R functions: data() for reading in data that comes with an R package double() for creating a numeric vector for storing real (non-integer) numbers toupper() for converting a string of characters from lowercase to uppercase All of these functions belong to the standard installation of R. You have also learned the following R functions that belong to the bioinformatics packages: nucleotideSubstitutionMatrix() in the Biostrings package for making a nucleotide scoring matrix pairwiseAlignment() in the Biostrings package for making a global alignment between two sequences c2s() in the SeqinR package for converting a sequence stored in a vector to a string of characters Links and Further Reading Some links are included here for further reading. For background reading on sequence alignment, it is recommended to read Chapter 3 of Introduction to Computational Genomics: a case studies approach by Cristianini and Hahn (Cambridge University Press; www.computational-genomics.net/book/). For more in-depth information and more examples on using the SeqinR package for sequence analysis, look at the SeqinR documentation, http://pbil.univ-lyon1.fr/software/seqinr/doc.php?lang=eng. There is also a very nice chapter on “Analyzing Sequences”, which includes examples of using SeqinR and Biostrings for sequence analysis, as well as details on how to implement algorithms such as Needleman-Wunsch and Smith-Waterman in R yourself, in the book Applied statistics for bioinformatics using R by Krijnen (available online at cran.r-project.org/doc/contrib/Krijnen-IntroBioInfStatistics.pdf). For a more in-depth introduction to R, a good online tutorial is available on the “Kickstarting R” website, cran.r-project.org/doc/contrib/Lemon-kickstart. There is another nice (slightly more in-depth) tutorial to R available on the “Introduction to R” website, cran.r-project.org/doc/manuals/R-intro.html. For more information on and examples using the Biostrings package, see the Biostrings documentation at http://www.bioconductor.org/packages/release/bioc/html/Biostrings.html. Acknowledgements Many of the ideas for the examples and exercises for this practical were inspired by the Matlab case study on the Eyeless protein (www.computational-genomics.net/case_studies/eyeless_demo.html) from the website that accompanies the book Introduction to Computational Genomics: a case studies approach by Cristianini and Hahn (Cambridge University Press; www.computational-genomics.net/book/). The examples of DNA sequences and protein sequences to align (‘GAATTC’ and ‘GATTA’, and sequences ‘PAWHEAE’ and ‘HEAGAWGHEE’), as well as some ideas related to finding the statistical significance of a pairwise alignment, were inspired by the chapter on “Analyzing Sequences” in the book Applied statistics for bioinformatics using R by Krijnen (cran.r-project.org/doc/contrib/Krijnen-IntroBioInfStatistics.pdf). Thank you to Jean Lobry and Simon Penel for helpful advice on using the SeqinR package. Contact I will be grateful if you will send me (Avril Coghlan) corrections or suggestions for improvements to my email address alc@sanger.ac.uk License The content in this book is licensed under a Creative Commons Attribution 3.0 License. Exercises Answer the following questions, using the R package. For each question, please record your answer, and what you typed into R to get this answer. Model answers to the exercises are given in Answers to the exercises on Sequence Alignment. Download FASTA-format files of the Brugia malayi Vab-3 protein (UniProt accession A8PZ80) and the Loa loa Vab-3 protein (UniProt accession E1FTG0) sequences from UniProt. Note: the vab-3 gene of Brugia malayi and the vab-3 gene of Loa loa are related genes that control eye development in these two species. Brugia malayi and Loa loa are both parasitic nematode worms, which both cause filariasis, which is classified by the WHO as a neglected tropical disease. What is the alignment score for the optimal global alignment between the Brugia malayi Vab-3 protein and the Loa loa Vab-3 protein, when you use the BLOSUM50 scoring matrix, a gap opening penalty of -10 and a gap extension penalty of -0.5? Note: to specify a gap opening penalty of -10 and a gap extension penalty of -0.5, set the “gapOpening” argument to -9.5, and the “gapExtension” penalty to -0.5 in the pairwiseAlignment() function. Use the printPairwiseAlignment() function to view the optimal global alignment between Brugia malayi Vab-3 protein and the Loa loa Vab-3 protein, using the BLOSUM50 scoring matrix, a gap opening penalty of -10 and a gap extension penalty of -0.5. Do you see any regions where the alignment is very good (lots of identities and few gaps)? What global alignment score do you get for the two Vab-3 proteins, when you use the BLOSUM62 alignment matrix, a gap opening penalty of -10 and a gap extension penalty of -0.5? Which scoring matrix do you think is more appropriate for using for this pair of proteins: BLOSUM50 or BLOSUM62? What is the statistical significance of the optimal global alignment for the Brugia malayi and Loa loa Vab-3 proteins made using the BLOSUM50 scoring matrix, with a gap opening penalty of -10 and a gap extension penalty of -0.5? In other words, what is the probability of getting a score as large as the real alignment score for Vab-3 by chance? What is the optimal global alignment score between the Brugia malayi Vab-6 protein and the Mycobacterium leprae chorismate lyase protein? Is the alignment score statistically significant (what is the P- value?)? Does this surprise you? "],["retrieving-multiple-sequences-in-r.html", "Chapter 15 Retrieving multiple sequences in R 15.1 Prelminaries 15.2 Retrieving a list of sequences from UniProt", " Chapter 15 Retrieving multiple sequences in R By: Avril Coghlan. Adapted and edited by Nathan Brouwer. 15.1 Prelminaries library(dayoff) library(rentrez) 15.2 Retrieving a list of sequences from UniProt Using websites or R you can search fort DNA or protein sequences in sequence databases such as the NCBI database and UniProt. Oftentimes, it is useful to retrieve several sequences at once. The R function entrez_fetch() from the rentrez package is useful for this purpose. (Other packages can also, this but rentrez has the cleanset interface). As its input, you need to give the entrez_fetch() a vector containing the accessions for the sequences you wish to retrieve, as well as the name of the ACNUC sub-database that the sequences should be retrieved from. In this case, we want to retrieve sequences from UniProt, so the sequences should be in the “swissprot” ACNUC sub-database. (It can be tricky to know exactly where to get sequences from sometimes so I will usually give you the code to do this). The entrez_fetch() function returns a list variable, in which each element is a separate vector containing one of the sequences of interest. **Lists* are a common data structure in R and can take some getting used to, but by working with them we will become familiar with how they work. Unfortunately there are some quirks to have R likes you to write code referring to lists, so I will frequently provide the necessary code for this. To retrieve the protein sequences for UniProt accessions P06747, P0C569, O56773 and Q5VKP1 (the accessions for rabies virus phosphoprotein, Mokola virus phosphoprotein, Lagos bat virus phosphoprotein and Western Caucasian bat virus phosphoprotein, respectively), you can type:ake a vector containing the names of the sequences. Note that the accessions aren’t numbers but are quoted character strings: seqnames &lt;- c(&quot;P06747&quot;, &quot;P0C569&quot;, &quot;O56773&quot;, &quot;Q5VKP1&quot;) Confirm that we are working with character data using is.character() We can access the first element of the vector using bracket notation like this: seqnames[1] Write the code to access the second and third elements of the vector of accessions: # 2nd accession # 3rd accession This code retrieves the first sequence and store them in list variable “seqs” seq1 &lt;- entrez_fetch(db = &quot;protein&quot;, id = seqnames[1], rettype = &quot;fasta&quot;) seq2 &lt;- entrez_fetch(db = &quot;protein&quot;, id = seqnames[2], rettype = &quot;fasta&quot;) seq3 &lt;- entrez_fetch(db = &quot;protein&quot;, id = seqnames[3], rettype = &quot;fasta&quot;) seq1 &lt;- fasta_cleaner(seq1, parse = T) seq2 &lt;- fasta_cleaner(seq2, parse = T) seq3 &lt;- fasta_cleaner(seq3, parse = T) Print out the first 20 letters of the first sequence seq1[1:20] Print out the first 20 letters of the second sequence seq2[1:20] seq3 &lt;- entrez_fetch(db = &quot;protein&quot;, id = seqnames, rettype = &quot;fasta&quot;) Rabies virus is the virus responsible for rabies, which is classified by the WHO as a neglected tropical disease. Mokola virus and rabies virus are closely related viruses that both belong to a group of viruses called the Lyssaviruses. Mokola virus causes a rabies-like infection in mammals including humans. Once you have retrieved the sequences using entrez_fetch(), you can then use the function write.fasta() from the SeqinR package to write the sequences to a FASTA-format file. As its arguments (inputs), the write.fasta() function takes the list variable containing the sequences, and a vector containing the names of the sequences, and the name that you want to give to the FASTA-format file. For example: write.fasta(seqs, seqnames, file=&quot;phosphoproteins.fasta&quot;) The command above will write the sequences in list variable seqs to a FASTA-format file called “phosphoproteins.fasta” in the “My Documents” folder on your computer. "],["computational-gene-finding.html", "Chapter 16 Computational gene finding 16.1 The genetic code 16.2 Reading frames 16.3 Finding open reading frames on the forward strand of a DNA sequence 16.4 Lengths of open reading frames", " Chapter 16 Computational gene finding By: Avril Coghlan, adapted by Nathan Brouwer 16.1 The genetic code A protein-coding gene starts with an “ATG”, which is followed by an integer (whole) number of codons (DNA triplets) that code for amino acids, and ends with a “TGA”, “TAA”, or “TAG”. That is, the start codon of a gene is always “ATG”, while the stop codon of a gene can be “TGA”, “TAA” or “TAG”. In R, you can view the standard genetic code, the correspondence between codons and the amino acids that they are translated into, by using the tablecode() function in the SeqinR package: library(seqinr) tablecode() You can see from this table that “ATG” is translated to Met (the amino acid methionine), and that “TAA”, “TGA” and “TAG” correspond to Stp (stop codons, which are not translated to any amino acid, but signal the end of translation). Finding start and stop codons in a DNA sequence To look for all the potential start and stop codons in a DNA sequence, we need to find all the “ATG”s, “TGA”s, “TAA”s, and “TAG”s in the sequence. To do this, we can use the “matchPattern()” function from the Biostrings R package, which identifies all occurrences of a particular motif (eg. “ATG”) in a sequence. As input, the matchPattern() function requires that the sequences be in the form of a string of single characters. For example, we can look for all “ATG”s in the sequence “AAAATGCAGTAACCCATGCCC” by typing: library(&quot;Biostrings&quot;) s1 &lt;- &quot;aaaatgcagtaacccatgccc&quot; matchPattern(&quot;atg&quot;, s1) # Find all ATGs in the sequence s1 The output from matchPattern() tells us that there are two “ATG”s in the sequence, at nucleotides 4-6, and at nucleotides 16-18. In fact, we can see these by looking at the sequence “AAAATGCAGTAACCCATGCCC”. Similarly, if you use matchPattern() to find the positions of “TAA”s, “TGA”s, and “TAG”s in the sequence “AAAATGCAGTAACCCATGCCC”, you will find that it has one “TAA” at nucleotides 10-12, but no “TAG”s or “TGA”s. The following R function “findPotentialStartsAndStops()” can be used to find all potential start and stop codons in a DNA sequence: To use the function, you will need to copy and paste it into R. For example, we can use this function to find potential start and stop codons in sequence s1: s1 &lt;- &quot;aaaatgcagtaacccatgccc&quot; findPotentialStartsAndStops(s1) The result of the function is returned as a list variable that contains two elements: the first element of the list is a vector containing the positions of potential start and stop codons in the input sequence, and the second element of the list is a vector containing the type of those start/stop codons (“atg”, “taa”, “tag”, or “tga”). The output for sequence s1 tells us that sequence s1 has an “ATG” starting at nucleotide 4, a “TAA” starting at nucleotide 10, and another “ATG” starting at nucleotide 16. We can use the function findPotentialStartsAndStops() to find all potential start and stop codons in longer sequences. For example, say we want to find all potential start and stop codons in the first 500 nucleotides of the genome sequence of the DEN-1 Dengue virus (NCBI accession NC_001477). In a previous chapter, you learnt that you can retrieve a sequence for an NCBI accession using the “getncbiseq()” function. Thus, to retrieve the genome sequence of the DEN-1 Dengue virus (NCBI accession NC_001477), we can type: dengueseq &lt;- getncbiseq(“NC_001477”) The variable dengueseq is a vector variable, and each letter in the DEN-1 Dengue virus DNA sequence is stored in one element of this vector. Dengue virus causes Dengue fever, which is classified as a neglected tropical disease by the WHO. To cut out the first 500 nucleotides of the DEN-1 Dengue virus sequence, we can just take the first 500 elements of this vector: dengueseqstart &lt;- dengueseq[1:500] Find the length of the “dengueseqstart” start vector length(dengueseqstart) Next we want to find potential start and stop codons in the first 500 nucleotides of the Dengue virus sequence. We can do this using the findPotentialStartsAndStops() function described above. However, the findPotentialStartsAndStops() function requires that the input sequence be in the format of a string of characters, rather than a vector. Therefore, we first need to convert the vector dengueseqstart into a string of characters. We can do that using the c2s() function in the SeqinR package: library(&quot;seqinr&quot;) # Load the SeqinR package dengueseqstart # Print out the vector dengueseqstart dengueseqstartstring &lt;- c2s(dengueseqstart) # Convert the vector &quot;dengueseqstart&quot; to a string of characters Print out the variable string of characters “dengueseqstartstring” dengueseqstartstring We can then find potential start and stop codons in the first 500 nucleotides of the DEN-1 Dengue virus sequence by typing: findPotentialStartsAndStops(dengueseqstartstring) We see that the lambda sequence has many different potential start and stop codons, for example, a potential stop codon (TAG) at nucleotide 7, a potential stop codon (TAA) at nucleotide 53, a potential stop codon (TAG) at nucleotide 58, and so on. 16.2 Reading frames Potential start and stop codons in a DNA sequence can be in three different possible reading frames. A potential start/stop codon is said to be in the +1 reading frame if there is an integer number of triplets x between the first nucleotide of the sequence and the start of the start/stop codon. Thus, a potential start/stop codon that begins at nucleotides 1 (0 triplets), 4 (1 triplet), 7 (2 triplets)… will be in the +1 reading frame. If there is an integer number of triplets x, plus one nucleotide (ie. x.3 triplets), between the first nucleotide of the sequence and the start of the start/stop codon, then the start/stop codon is said to be in the +2 reading frame. A potential start/stop codon that begins at nucleotides 2 (0.3 triplets), 5 (1.3 triplets), 8 (2.3 triplets) … is in the +2 reading frame. Similarly, if there is an integer number of triplets x, plus two nucleotides (ie. x.6 triplets), between the first nucleotides of the sequence and the start of the start/stop codon, the start/stop codon is in the +3 reading frame. So a potential start/stop codon that begins at nucleotides 3 (0.6 triplets), 6 (1.6 triplets), 9 (2.6 triplets)… is in the +3 reading frame. For a potential start and stop codon to be part of the same gene, they must be in the same reading frame. From the output of findPotentialStartsAndStops() for the first 500 nucleotides of the genome of DEN-1 Dengue virus (see above), you can see that there is a potential start codon (ATG) that starts at nucleotide 137, and a potential stop codon (TGA) that starts at nucleotide 141. That is, the potential start codon is from nucleotides 137-139 and the potential stop codon is from nucleotides 141-143. Could the region from nucleotides 137 to 143 possibly be a gene? We can cut out the region from nucleotides 137 to 143 of the sequence dengueseqstartstring to have a look, by using the substring() function. If you look at the help page for the substring() function, you will see that its arguments (inputs) are the name of the variable containing the string of characters (ie., the DNA sequence), and the coordinates of the substring that you want: substring(dengueseqstartstring,137,143) If we look at the sequence from nucleotides 137-143, “ATGCTGA”, we see that it starts with a potential start codon (ATG) and ends with a potential stop codon (TGA). However, the ribosome reads the sequence by scanning the codons (triplets) one-by-one from left to right, and when we break up the sequence into codons (triplets) we see that it does not contain an integer (whole) number of triplets: “ATG CTG A”. This means that even if the ribosome will not recognise the region from 137-143 as a potential gene, as the ATG at nucleotide 137 is not separated from the TGA at nucleotide 141 by an integer number of codons. That is, this ATG and TGA are not in the same reading frame, and so cannot be the start and stop codon of the same gene. The potential start codon at nucleotide 137 of the lambdaseqstartstring sequence is in the +2 reading frame, as there is an integer number of triplets, plus one nucleotide, between the start of the sequence and the start of the start codon (ie. triplets 1-3, 4-6, 7-9, 10-12, 13-15, 16-18, 19-21, 22-24, 25-27, 28-30, …, 133-135, and a single nucleotide 136). However, the potential stop codon at nucleotide 141 is the +3 reading frame, as there are two nucleotides plus an integer number of triplets between the start of the sequence and the start of the stop codon (ie. triplets 1-3, 4-6, 7-9, 10-12, 13-15, 16-18, 19-21, 22-24, 25-27, 28-30, 31-33, 34-36, 37-39, 40-42, 43-45, …, 133-135, 136-138, and two nucleotides 139, 140). As the potential start codon at nucleotide 137 and the potential stop codon at nucleotide 141 are in different reading frames, they are not separated by an integer number of codons, and therefore cannot be part of the same gene. 16.3 Finding open reading frames on the forward strand of a DNA sequence To find potential genes, we need to look for a potential start codon, followed by an integer number of codons, followed by a potential stop codon. This is eqivalent to looking for a potential start codon followed by a potential stop codon that is in the same reading frame. Such a stretch of DNA is known as an open reading frame (ORF), and is a good candidate for a potential gene. The following function plotPotentialStartsAndStops() plots the potential start and stop codons in the three different reading frames of a DNA sequence: To use this function, you will first need to copy and paste it into R. For example, to plot the potential start and stop codons in the first 500 nucleotides of the DEN-1 Dengue virus genome, we type: plotPotentialStartsAndStops(dengueseqstartstring) In the picture produced by plotPotentialStartsAndStops(), the x-axis represents the input sequence (dengueseqstartstring here). The potential start codons are represented by vertical red lines, and potential stop codons are represented by vertical blue lines. Three different layers in the picture show potential start/stop codons in the +1 reading frame (bottom layer), +2 reading frame (middle layer), and +3 reading frame (top layer). We can see that the start codon at nucleotide 137 is represented by a vertical red line in the layer corresponding to the +2 reading frame (middle layer). There are no potential stop codons in the +2 reading frame to the right of that start codon. Thus, the start codon at nucleotide 137 does not seem to be part of an open reading frame. We can see however that in the +3 reading frame (top layer) there is a predicted start codon (red line) at position 318 and that this is followed by a predicted stop codon (blue line) at position 371. Thus, the region from nucleotides 318 to 371 could be a potential gene in the +3 reading frame. In other words, the region from nucleotides 318 to 371 is an open reading frame, or ORF. For example, we can use findORFsinSeq to find all ORFs in the sequence s1: s1 &lt;- &quot;aaaatgcagtaacccatgccc&quot; findORFsinSeq(s1) The function findORFsinSeq() returns a list variable, where the first element of the list is a vector of the start positions of ORFs, the second element of the list is a vector of the end positions of those ORFs, and the third element is a vector containing the lengths of the ORFs. The output for the findORFsinSeq() function for s1 tells us that there is one ORF in the sequence s1, and that the predicted start codon starts at nucleotide 4 in the sequence, and that the predicted stop codon ends at nucleotide 12 in the sequence. We can use the function findORFsinSeq() to find the ORFs in the first 500 nucleotides of the DEN-1 Dengue virus genome sequence by typing: findORFsinSeq(dengueseqstartstring) The result from findORFsinSeq() indicates that there are two ORFs in the first 500 nucleotides of the DEN-1 Dengue virus genome, at nucleotides 298-480 (start codon at 298-300, stop codon at 478-480), and 318-371 (start codon at 318-320, stop codon at 369-371). The following function “plotORFsinSeq()” plots the positions of ORFs in a sequence: To use this function, you will first need to copy and paste it into R. You can then use this function to plot the positions of the ORFs in dengueseqstartstring by typing: plotORFsinSeq(dengueseqstartstring) The picture produced by plotORFsinSeq() represents the two ORFs in the first 500 nucleotides of the lambda genome as blue rectangles. One of the ORFs is in the +3 reading frame, and one is in the +1 reading frame. There are no ORFs in the +2 reading frame, as there are no potential stop codons to the right (3’) of the potential start codons in the +2 reading frame, as we can see from the picture produced by plotPotentialStartsAndStops() above. Predicting the protein sequence for an ORF If you find an ORF in a DNA sequence, it is interesting to find the DNA sequence of the ORF. For example, the function findORFsinSeq() indicates that there is an ORF from nucleotides 4-12 of the sequence s1 (aaaatgcagtaacccatgccc). To look at the DNA sequence for just the ORF, we can use the substring() function to cut out that piece of DNA. For example, to cut out the substring of sequence s1 that corresponds to the ORF from nucleotides 4-12, we type: s1 &lt;- &quot;aaaatgcagtaacccatgccc&quot; myorf &lt;- substring(s1, 4, 12) myorf # Print out the sequence of &quot;myorf&quot; As you can see, the ORF starts with a predicted start codon (ATG), is followed by an integer number of codons (just one codon, CAG, in this case), and ends with a predicted stop codon (TAA). If you have the DNA sequence of an ORF, you can predict the protein sequence for the ORF by using the translate() function from the SeqinR package. Note that as there is a function called translate() in both the Biostrings and SeqinR packages, we need to type seqinr::translate() to specify that we want to use the SeqinR translate() function. The translate() function requires that the input sequence be in the form of a vector of characters. If your sequence is in the form of a string of characters, you can convert it to a vector of characters using the s2c() function from the SeqinR package. For example, to predict the protein sequence of the ORF myorf, you would type: myorfvector &lt;- s2c(myorf) # Convert the sequence of characters to a vector myorfvector # Print out the value of &quot;myorfvector&quot; seqinr::translate(myorfvector) From the output of the seqinr::translate() function, we see that the predicted start codon (ATG) is translated as a Methionine (M), and that this is followed by a Glutamine (Q). The predicted stop codon is represented as “*” as it is not translated into any amino acid. Finding open reading frames on the reverse strand of a DNA sequence Genes in a genome sequence can occur either on the forward (plus) strand of the DNA, or on the reverse (minus) strand. To find ORFs on the reverse strand of a sequence, we must first infer the reverse strand sequence, and then use our findORFsinSeq() function to find ORFs on the reverse strand. The reverse strand sequence easily can be inferred from the forward strand sequence, as it is always the reverse complement sequence of the forward strand sequence. We can use the comp() function from the SeqinR package to calculate the complement of a sequence, and the rev() function to reverse that sequence in order to give us the reverse complement sequence. The comp() and rev() functions require that the input sequence is in the form of a vector of characters. The s2c() function can be used to convert a sequence in the form of a string of characters to a vector, while the c2s() function is useful for convering a vector back to a string of characters. For example, if our forward strand sequence is “AAAATGCTTAAACCATTGCCC”, and we want to find the reverse strand sequence, we type: forward &lt;- &quot;AAAATGCTTAAACCATTGCCC&quot; forwardvector &lt;- s2c(forward) # Convert the string of characters to a vector forwardvector # Print out the vector containing the forward strand sequence reversevector &lt;- rev(comp(forwardvector)) # Find the reverse strand sequence, by finding the reverse complement Print out the vector containing the reverse strand sequence reversevector Convert the vector to a string of characters reverse &lt;- c2s(reversevector) Print out the string of characters containing the reverse strand sequence reverse In the command reversevector &lt;- rev(comp(forwardvector)) above, we are first using the comp() function to find the complement of the forward strand sequence. We are then using the rev() function to take the output sequence given by comp() and reverse the order of the letters in that sequence. An equivalent way of doing the same thing would be to type: Find the complement of the forward strand sequence complement &lt;- comp(forwardvector) Reverse the order of the letters in sequence “complement”, to find the reverse strand sequence (the reverse complement sequence) reversevector &lt;- rev(complement) # Once we have inferred the reverse strand sequence, we can then use the findORFsinSeq() function to find ORFs in the reverse strand sequence: findORFsinSeq(reverse) This indicates that there is one ORF of length 9 bp in the reverse strand of sequence “AAAATGCTTAAACCATTGCCC”, that has a predicted start codon that starts at nucleotide 6 in the reverse strand sequence and a predicted stop codon that ends at nucleotide 14 in the reverse strand sequence. 16.4 Lengths of open reading frames As you can see from the picture displaying the genetic code made using tablecode() (above), three of the 64 different codons are stop codons. This means that in a random DNA sequence the probability that any codon is a potential stop codon is 3/64, or about 1/21 (about 5%). Therefore, you might expect that sometimes potential start and stop codons can occur in a DNA sequence just due to chance alone, not because they are actually part of any real gene that is transcribed and translated into a protein. As a result, many of the ORFs in a DNA sequence may not correspond to real genes, but just be stretches of DNA between potential start and stop codons that happened by chance to be found in the sequence. In other words, an open reading frame (ORF) is just a gene prediction, or a potential gene. It may correspond to a real gene (may be a true positive gene prediction), but it may not (may be a false positive gene prediction). How can we tell whether the potential start and stop codons of an ORF are probably real start and stop codons, that is, whether an ORF probably corresponds to a real gene that is transcribed and translated into a protein? In fact, we cannot tell using bioinformatics methods alone (we actually need to do some lab experiments to know), but we can make a fairly confident prediction. We can make our prediction based on the length of the ORF. y definition, an ORF is a stretch of DNA that starts with a potential start codon, and ends with a potential stop codon in the same reading frame, and so has no internal stop codons in that reading frame. Because about 1/21 of codons (~5%) in a random DNA sequence are expected to be potential stop codons just by chance alone, if we see a very long ORF of hundreds of codons, it would be surprising that there would be no internal stop codons in such a long stretch of DNA if the ORF were not a real gene. In other words, long ORFs that are hundreds of codons long are unlikely to occur due to chance alone, and therefore we can be fairly confident that such long ORFs probably correspond to real genes. "],["significance-of-orfs.html", "Chapter 17 Significance of ORFs 17.1 Identifying significant open reading frames 17.2 Summary", " Chapter 17 Significance of ORFs By: Avril Coghlan. Adapted and edited by Nathan Brouwer. 17.1 Identifying significant open reading frames How long does an ORF need to be in order for us to be confident that it probably corresponds to a real gene? This is a difficult question. One approach to answer this is to ask: what is the longest ORF found in a random sequence of the same length and nucleotide composition as our original sequence? The ORFs in a random sequence do not correspond to real genes, but are just due to potential start and stop codons that have occurred by chance in those sequences (since, by definition, a random sequence is one that was generated randomly, rather than by evolution as in a real organism). Thus, by looking at the lengths of ORFs in the random sequence, we can see what is the longest ORF that is likely to occur by chance alone. But where can we get random sequences from? In a previous chapter, you learnt that you can generate random sequences using a multinomial model with a particular probability of each letter (a particular probability of A, C, G, and T in the case of random DNA sequences). In that previous chapter, we used the function generateSeqsWithMultinomialModel() to generate random sequences using a multinomial model in which the probability of each letter is set equal to the fraction of an input sequence that consists of that letter. This function takes two arguments, the input sequence, and the number of the random sequences that you want to generate. For example, to create a random sequence of the same length as ‘AAAATGCTTAAACCATTGCCC’, using a multinomial model in which the probabilities of A, C, G and T are set equal to their fractions in this sequence, we copy and paste the generateSeqsWithMultinomialModel() into R, then type: myseq &lt;- &quot;AAAATGCTTAAACCATTGCCC&quot; Generate one random sequence using the multinomial model generateSeqsWithMultinomialModel(myseq, 1) We can then use the findORFsinSeq() function to find ORFs in this random sequence. If we repeat this 10 times, we can find the lengths of the ORFs found in the 10 random sequences. We can then compare the lengths of the ORFs found in the original sequence, to the lengths of the ORFs found in the random sequences. For example, to compare the lengths of ORFs found in the DEN-1 Dengue virus genome sequence dengueseq to the lengths of ORFs found in 10 random sequences generated using a multinomial model in which the probabilities of the four bases are set equal to their fractions in the DEN-1 Dengue virus sequence, we type: #Convert the Dengue sequence to a string of characters dengueseqstring &lt;- c2s(dengueseq) Find ORFs in “dengueseqstring” mylist &lt;- findORFsinSeq(dengueseqstring) Find the lengths of ORFs in “dengueseqstring” orflengths &lt;- mylist[[3]] Generate 10 random sequences using the multinomial model randseqs &lt;- generateSeqsWithMultinomialModel(dengueseqstring, 10) Tell R that we want to make a new vector of numbers randseqorflengths &lt;- numeric() for (i in 1:10) { print(i) randseq &lt;- randseqs[i] # Get the ith random sequence mylist &lt;- findORFsinSeq(randseq) # Find ORFs in &quot;randseq&quot; lengths &lt;- mylist[[3]] # Find the lengths of ORFs in &quot;randseq&quot; randseqorflengths &lt;- append(randseqorflengths, lengths, after=length(randseqorflengths)) } This may take a little time to run, however, the for loop above prints out the value of i each time that it starts the loop, so you can see how far it has got. In the code above, we retrieve the lengths of the ORFs found by function findORFsinSeq() by taking the third element of the list returned by this function. As mentioned above, the third element of the list returned by this function is a vector containing the lengths of all the ORFs found in the input sequence. We can then plot a histogram of the lengths of the ORFs in the real DEN-1 Dengue genome sequence (orflengths) beside a histogram of the lengths of the ORFs in the 10 random sequences (randseqorflengths): par(mfrow = c(1,2)) # Make a picture with two plots side-by-side (one row, two columns) bins &lt;- seq(0,11000,50) # Set the bins for the histogram hist(randseqorflengths, breaks=bins, col=&quot;red&quot;, xlim=c(0,1000)) hist(orflengths, breaks=bins, col=&quot;red&quot;, xlim=c(0,1000)) In other words, the histogram of the lengths of the ORFs in the 10 random sequences gives us an idea of the length distribution of ORFs that you would expect by chance alone in a random DNA sequence (generated by a multinomial model in which the probabilities of the four bases are set equal to their frequencies in the DEN-1 Dengue virus genome sequence). We can calculate the longest of the ORFs that occurs in the random sequences, using the max() function, which can be used to find the largest element in a vector of numbers: max(randseqorflengths) This indicates that the longest ORF that occurs in the random sequences is 342 nucleotides long. Thus, it is possible for an ORF of up to 342 nucleotides to occur by chance alone in a random sequence of the same length and roughly the same composition as the DEN-1 Dengue virus genome. Therefore, we could use 342 nucleotides as a threshold, and discard all ORFs found in the DEN-1 Dengue virus genome that are shorter than this, under the assumption that they probably arose by chance and probably do not correspond to real genes. How many ORFs would be left in the DEN-1 Dengue virus genome sequence if we used 342 nucleotides as a threshold? summary(orflengths) If we did use 342 nucleotides as a threshold, there would only be 1 ORF left in the DEN-1 Dengue virus genome. Some of the 115 shorter ORFs that we discarded may correspond to real genes. Generally, we don’t want to miss many real genes, we may want to use a more tolerant threshold. For example, instead of discarding all Dengue ORFs that are shorter than the longest ORF found in the 10 random sequences, we could discard all Dengue ORFs that are shorter than the longest 99% of ORFs in the random sequences. We can use the quantile() function to find quantiles of a set of numbers. The 99th quantile for a set of numbers is the value x such that 99% of the numbers in the set have values less than x. For example, to find the 99th quantile of randomseqorflengths, we type: quantile(randseqorflengths, probs=c(0.99)) This means that 99% of the ORFs in the random sequences have lengths less than 248 nucleotides long. In other words, the longest of the longest 99% of ORFs in the random sequences is 248 nucleotides. Thus, if we were using this as a threshold, we would discard all ORFs from the DEN-1 Dengue genome that are 248 nucleotides or shorter. This will result in fewer ORFs being discarded than if we used the more stringent threshold of 342 nucleotides (ie. discarding all ORFs of &lt;342 nucleotides), so we will probably have discarded fewer ORFs that correspond to real genes. Unfortunately, it probably means that we will also have kept more false positives at the same time, that is, ORFs that do not correspond to real genes. 17.2 Summary In this practical, you will have learnt to use the following R functions: substring() for cutting out a substring of a string of characters (eg. a subsequence of a DNA sequence) rev() for reversing the order of the elements in a vector hist() to make a histogram plot max() to find the largest element in a vector of numbers quantile() to find quantiles of a set of numbers that correspond to particular probabilities All of these functions belong to the standard installation of R. You have also learnt the following R functions that belong to the bioinformatics packages: tablecode() in the SeqinR package for viewing the genetic code MatchPattern() in the Biostrings package for finding all occurrences of a motif in a sequence translate() in the SeqinR package to get the predicted protein sequence for an ORF s2c() in the SeqinR package to convert a sequence stored as a string of characters into a vector c2s() in the SeqinR package to convert a sequence stored in a vector into a string of characters comp() in the SeqinR package to find the complement of a DNA sequence Links and Further Reading Some links are included here for further reading. For background reading on computational gene-finding, it is recommended to read Chapter 2 of Introduction to Computational Genomics: a case studies approach by Cristianini and Hahn (Cambridge University Press; www.computational-genomics.net/book/). For more in-depth information and more examples on using the SeqinR package for sequence analysis, look at the SeqinR documentation, http://pbil.univ-lyon1.fr/software/seqinr/doc.php?lang=eng. For more information on and examples using the Biostrings package, see the Biostrings documentation at http://www.bioconductor.org/packages/release/bioc/html/Biostrings.html. There is also a very nice chapter on “Analyzing Sequences”, which includes examples of using the SeqinR and Biostrings packages for sequence analysis, in the book Applied statistics for bioinformatics using R by Krijnen (available online at cran.r-project.org/doc/contrib/Krijnen-IntroBioInfStatistics.pdf). For a more in-depth introduction to R, a good online tutorial is available on the “Kickstarting R” website, cran.r-project.org/doc/contrib/Lemon-kickstart. There is another nice (slightly more in-depth) tutorial to R available on the “Introduction to R” website, cran.r-project.org/doc/manuals/R-intro.html. Acknowledgements Many of the ideas for the examples and exercises for this practical were inspired by the Matlab case study on the Haemophilus influenzae genome (www.computational-genomics.net/case_studies/haemophilus_demo.html) from the website that accompanies the book Introduction to Computational Genomics: a case studies approach by Cristianini and Hahn (Cambridge University Press; www.computational-genomics.net/book/). Thank you to Jean Lobry and Simon Penel for helpful advice on using the SeqinR package. Exercises Answer the following questions, using the R package. For each question, please record your answer, and what you typed into R to get this answer. Model answers to the exercises are given in Answers to the exercises on Computational Gene-finding. How many ORFs are there on the forward strand of the DEN-1 Dengue virus genome (NCBI accession NC_001477)? What are the coordinates of the rightmost (most 3’, or last) ORF in the forward strand of the DEN-1 Dengue virus genome? What is the predicted protein sequence for the rightmost (most 3’, or last) ORF in the forward strand of the DEN-1 Dengue virus genome? How many ORFs are there of 30 nucleotides or longer in the forward strand of the DEN-1 Dengue virus genome sequence? How many ORFs longer than 248 nucleotides are there in the forward strand of the DEN-1 Dengue genome sequence? If an ORF is 248 nucleotides long, what length in amino acids will its predicted protein sequence be? How many ORFs are there on the forward strand of the rabies virus genome (NCBI accession NC_001542)? Note: rabies virus is the virus responsible for rabies, which is classified by the WHO as a neglected tropical disease. What is the length of the longest ORF among the 99% of longest ORFs in 10 random sequences of the same lengths and composition as the rabies virus genome sequence? How many ORFs are there in the rabies virus genome that are longer than the threshold length that you found in Q8? "],["rooted-neighbor-joining-phylogenetic-trees.html", "Chapter 18 Rooted Neighbor-joining Phylogenetic trees 18.1 Building a rooted phylogenetic tree for protein sequences 18.2 Building a phylogenetic tree for DNA or mRNA sequences 18.3 Summary", " Chapter 18 Rooted Neighbor-joining Phylogenetic trees By: Avril Coghlan. Adapted and edited by Nathan Brouwer. 18.1 Building a rooted phylogenetic tree for protein sequences In order to convert the unrooted tree into a rooted tree, we need to add an outgroup sequence. Normally, the outgroup sequence is a sequence that we know from some prior knowledge to be more distantly related to the other sequences under study than they are to each other. For example, the protein Fox-1 is involved in determining the sex of an embryo in the nematode worm Caenorhabditis elegans (UniProt accession Q10572). Related proteins are found in other nematodes, including Caenorhabditis remanei (UniProt E3M2K8), Caenorhabditis briggsae (A8WS01), Loa loa (E1FUV2), and Brugia malayi (UniProt A8NSK3). Note that Caenorhabditis elegans is a model organism commonly studied in molecular biology. The nematodes Loa loa, and *Brugia malayi() are parasitic nematodes that cause filariasis, which is classified by the WHO as a neglected tropical disease. The UniProt database contains a distantly related sequence from the fruit fly Drosophila melanogaster (UniProt accession Q9VT99). If we were to build a phylogenetic tree of the nematode worm Fox-1 homologues, the distantly related sequence from fruitfly would probably be a good choice of outgroup, since the protein is from a different animal group (insects) than the nematode worms. Thus, it is likely that the fruitfly protein is more distantly related to all the nematode proteins than they are to each other. To retrieve the sequences from UniProt we can use the “retrieveseqs()” function (see above): seqnames &lt;- c(&quot;Q10572&quot;,&quot;E3M2K8&quot;,&quot;Q8WS01&quot;,&quot;E1FUV2&quot;,&quot;A8NSK3&quot;,&quot;Q9VT99&quot;) seqs &lt;- retrieveseqs(seqnames,&quot;swissprot&quot;) We can then write out the sequences to a FASTA file: write.fasta(seqs, seqnames, file=&quot;fox1.fasta&quot;) We can then use CLUSTAL to create a PHYLIP-format alignment of the sequences, and store it in the alignment file “fox1.phy”. This picture shows part of the alignment (the alignment is quite long, so not all of it is shown): image10 We can then read the alignment into R: fox1aln &lt;- read.alignment(file = &quot;fox1.phy&quot;, format = &quot;phylip&quot;) The next step is to build a phylogenetic tree of the proteins, which again we can do using the neighbour-joining algorithm. This time we have an outgroup in our set of sequences, so we can build a rooted tree. The function “rootedNJtree()” can be used to build a rooted tree. It returns the phylogenetic tree, and also makes a picture of the tree: The function takes the alignment and the name of the outgroup as its inputs. For example, to use it to make a phylogenetic tree of the C. elegans Fox-1 protein and its homologues, using the fruitfly protein (UniProt Q9VT99) as the outgroup, we type: fox1alntree &lt;- rootedNJtree(fox1aln, &quot;Q9VT99&quot;,type=&quot;protein&quot;) Here we can see that E3M2K8 (C. remanei Fox-1 homologue) and Q10572 (C. elegans Fox-1) have been grouped together with bootstrap 100%, and A8NSK3 (Brugia malayi Fox-1 homologue) and E1FUV2 (Loa loa Fox-1 homologue) have been grouped together with bootstrap 100%. These four proteins have also been grouped together in a larger clade with bootstrap 100%. Compared to these four proteins, the Q8WS01 (C. briggsae Fox-1 homologue) and Q9VT99 (fruitfly outgroup) seem to be relatively distantly related. As this is a rooted tree, we know the direction that evolutionary time ran. Say we call the ancestor of the four sequences (E3M2K8, Q10572, A8NSK3, E1FUV2) ancestor1, the ancestor of the two sequences (E3M2K8, Q10572) ancestor2, and the ancestor of the two sequences (A8NSK3, E1FUV2) ancestor3. Because it is a rooted tree, we know that time ran from left to right along the branches of the tree, so that ancestor1 was the ancestor of ancestor2, and ancestor1 was also the ancestor of ancestor3. In other words, ancestor1 lived before ancestor2 or ancestor3; ancestor2 and ancestor3 were descendants of ancestor1. Another way of saying this is that E3M2K8 and Q10572 shared a common ancestor with each other more recently than they did with A8NSK3 and E1FUV2. The lengths of branches in this tree are proportional to the amount of evolutionary change (estimated number of mutations) that occurred along the branches. The branches leading back from E3M2K8 and Q10572 to their last common ancestor are slightly longer than the branches leading back from A8NSK3 and E1FUV2 to their last common ancestor. This indicates that there has been more evolutionary change in E3M2K8 (C. remanei Fox-1 homologue) and Q10572 (C. elegans Fox-1) proteins since they diverged, than there has been in A8NSK3 (Brugia malayi Fox-1 homologue) and E1FUV2 (Loa loa Fox-1 homologue) since they diverged. 18.2 Building a phylogenetic tree for DNA or mRNA sequences In the example above, a phylogenetic tree was built for protein sequences. The genomes of distantly related organisms such as vertebrates will have accumulated many mutations since they diverged. Sometimes, so many mutations have occurred since the organisms diverged that their DNA sequences are hard to align correctly and it is also hard to accurately estimate evolutionary distances from alignments of those DNA sequences. In contrast, as many mutations at the DNA level are synonymous at the protein level, protein sequences diverge at a slower rate than DNA sequences. This is why for reasonably distantly related organisms such as vertebrates, it is usually preferable to use protein sequences for phylogenetic analyses. If you are studying closely related organisms such as primates, few mutations will have occurred since they diverged. As a result, if you use protein sequences for a phylogenetic analysis, there may be too few amino acid substitutions to provide enough ‘signal’ to use for the phylogenetic analysis. Therefore, it is often preferable to use DNA sequences for a phylogenetic analysis of closely related organisms such as primates. We can use the functions unrootedNJtree() and rootedNJtree() described above to build unrooted or rooted neighbour-joining phylogenetic trees based on an alignment of DNA or mRNA sequences. In this case, we need to use “type=DNA” as an argument in these functions, to tell them that we are making a tree of nucleotide sequences, not protein sequences. For example, to build an unrooted phylogenetic tree based on the alignment of the virus phosphoprotein mRNA sequences, we type in R: virusmRNAaln &lt;- read.alignment(file = &quot;virusmRNA.phy&quot;, format = &quot;phylip&quot;) virusmRNAalntree &lt;- unrootedNJtree(virusmRNAaln, type=&quot;DNA&quot;) Saving a phylogenetic tree as a Newick-format tree file A commonly used format for representing phylogenetic trees is the Newick format. Once you have built a phylogenetic tree using R, it is convenient to store it as a Newick-format tree file. This can be done using the “write.tree()” function in the Ape R package. For example, to save the unrooted phylogenetic tree of virus phosphoprotein mRNA sequences as a Newick-format tree file called “virusmRNA.tre”, we type: write.tree(virusmRNAalntree, &quot;virusmRNA.tre&quot;) The Newick-format file “virusmRNA.tre” should now appear in your “My Documents” folder. 18.3 Summary In this practical, you have learnt the following R functions that belong to the bioinformatics packages: read.alignment() from the SeqinR package for reading in a multiple alignment dist.alignment() from the SeqinR package for calculating genetic distances between protein sequences dist.dna() from the Ape package for calculating genetic distances between DNA or mRNA sequences Links and Further Reading Some links are included here for further reading. For background reading on phylogenetic trees, it is recommended to read Chapter 7 of Introduction to Computational Genomics: a case studies approach by Cristianini and Hahn (Cambridge University Press; www.computational-genomics.net/book/). Another more in-depth (but very accesssible) book on phylogenetics is Molecular Evolution: A Phylogenetic Approach by Roderic DM Page and Edward C Holmes. For more in-depth information and more examples on using the SeqinR package for sequence analysis, look at the SeqinR documentation, http://pbil.univ-lyon1.fr/software/seqinr/doc.php?lang=eng. For more in-depth information and more examples on the Ape package for phylogenetic analysis, look at the Ape documentation, ape.mpl.ird.fr/. If you are using the Ape package for a phylogenetic analysis project, it would be worthwhile to obtain a copy of the book Analysis of Phylogenetics and Evolution with R by Emmanuel Paradis, published by Springer, which has many nice examples of using R for phylogenetic analyses. For a more in-depth introduction to R, a good online tutorial is available on the “Kickstarting R” website, cran.r-project.org/doc/contrib/Lemon-kickstart. There is another nice (slightly more in-depth) tutorial to R available on the “Introduction to R” website, cran.r-project.org/doc/manuals/R-intro.html. Acknowledgements Many of the ideas for the examples and exercises for this practical were inspired by the Matlab case study on SARS (www.computational-genomics.net/case_studies/sars_demo.html) from the website that accompanies the book Introduction to Computational Genomics: a case studies approach by Cristianini and Hahn (Cambridge University Press; www.computational-genomics.net/book/). Thank you to Jean Lobry and Simon Penel for helpful advice on using the SeqinR package. Thank you to Emmanuel Paradis and François Michonneau for help in using the Ape package. Thank you also to Klaus Schliep for helpful comments. Contact I will be grateful if you will send me (Avril Coghlan) corrections or suggestions for improvements to my email address alc@sanger.ac.uk License The content in this book is licensed under a Creative Commons Attribution 3.0 License. Exercises Answer the following questions, using the R package. For each question, please record your answer, and what you typed into R to get this answer. Model answers to the exercises are given in Answers to the exercises on Multiple Alignment and Phylogenetic Trees. Calculate the genetic distances between the following NS1 proteins from different Dengue virus strains: Dengue virus 1 NS1 protein (Uniprot Q9YRR4), Dengue virus 2 NS1 protein (UniProt Q9YP96), Dengue virus 3 NS1 protein (UniProt B0LSS3), and Dengue virus 4 NS1 protein (UniProt Q6TFL5). Which are the most closely related proteins, and which are the least closely related, based on the genetic distances? Note: Dengue virus causes Dengue fever, which is classified by the WHO as a neglected tropical disease. There are four main types of Dengue virus, Dengue virus 1, Dengue virus 2, Dengue virus 3, and Dengue virus 4. Build an unrooted phylogenetic tree of the NS1 proteins from Dengue virus 1, Dengue virus 2, Dengue virus 3 and Dengue virus 4, using the neighbour-joining algorithm. Which are the most closely related proteins, based on the tree? Based on the bootstrap values in the tree, how confident are you of this? Build an unrooted phylogenetic tree of the NS1 proteins from Dengue viruses 1-4, based on a filtered alignment of the four proteins (keeping alignment columns in which at least 30% of letters are not gaps, and in which at least 30% of pairs of letters are identical). Does this differ from the tree based on the unfiltered alignment (in Q2)? Can you explain why? The Zika virus is related to Dengue viruses, but is not a Dengue virus, and so therefore can be used as an outgroup in phylogenetic trees of Dengue virus sequences. UniProt accession Q32ZE1 consists of a sequence with similarity to the Dengue NS1 protein, so seems to be a related protein from Zika virus. Build a rooted phylogenetic tree of the Dengue NS1 proteins based on a filtered alignment (keeping alignment columns in which at least 30% of letters are not gaps, and in which at least 30% of pairs of letters are identical), using the Zika virus protein as the outgroup. Which are the most closely related Dengue virus proteins, based on the tree? What extra information does this tree tell you, compared to the unrooted tree in Q2? "],["todo.html", "Chapter 19 TODO", " Chapter 19 TODO Copy text and code from original website to .rmd files Move any functions AC wrote to .R files Move code into R code chunks Compile list of packages used in the chapter; make sure these are loaded at beginning of chapter Compile list of AC functions used in the chapter Compile list of dad used in the chapter Add AC functions to biodata package Add dat to the biodata package Make sure biodata gets called at beginning of chapter to load any ASC "],["references.html", "References", " References "]]
