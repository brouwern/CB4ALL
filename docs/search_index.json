[["index.html", "Computational Biology for All Chapter 1 Boilerplate", " Computational Biology for All Avril Coglan and Nathan Brouwer 2021-01-02 Chapter 1 Boilerplate This book is based Dr. Avril Coghlan’s A little book of R for bioinformatics.. Much of the text and code was originally written by Dr. Coghlan and distributed under the Creative Commons 3.0 license. To compile this to PDF, you need XeLaTeX. You are recommended to install TinyTeX (which includes XeLaTeX): https://yihui.org/tinytex/. "],["introduction.html", "Chapter 2 Introduction 2.1 Changes made to original source", " Chapter 2 Introduction This book is based Dr. Avril Coghlan’s A little book of R for bioinformatics.. Much of the text and code was originally written by Dr. Coghlan and distributed under the Creative Commons 3.0 license. 2.1 Changes made to original source To meet the needs of my course I have Edited the original HTML document into RMarkdown Used the RStudio IDE instead of the basic R IDE Split up Coghlan’s original chapters into short lessons Placed functions written by Coghlan into an R package instead of requiring that they be loaded by hand. Changed which functions or packages are used; for example, replacing some SeqinR functions with rentrez functions. Added additional plots and changed some plotting functions, such as using ggplot2 and ggpubr. Removed .jpg images; I hope to add these back Fixed typos, removed dead links, and additional links, turned links to hypertext, converted to American English (sorry!) Added a summary section at the beginning listing the functions, vocabulary, software, organism, accession numbers "],["downloading-r.html", "Chapter 3 Downloading R 3.1 Introduction to R 3.2 Installing R 3.3 Starting R", " Chapter 3 Downloading R The following introduction to R is based on the first part of “How to install R and a Brief Introduction to R” by Avril Coghlan. For additional information see “Getting R onto your compute”. 3.1 Introduction to R R (www.r-project.org) is a commonly used free statistics software. R allows you to carry out statistical analyses in an interactive mode, as well as allowing simple programming. 3.2 Installing R To use R, you first need to install the R program on your computer. 3.2.1 Installing R on a Windows PC These instructions will focus on installing R on a Windows PC. However, I will also briefly mention how to install R on a Macintosh or Linux computer (see below). These steps have not been checked as of 8/13/2019 so there may be small variations in what the prompts are. Installing are, however, is basically that same as any other program. Clicking “Yes” etc on everything should work. Note that even if you have used R before its good to regularly update it to avoid conflicts with recently produced software. New releases of R are made very regularly (approximately once a month), as R is actively being improved all the time. It is worthwhile installing new versions of R regularly, to make sure that you have a recent version of R (to ensure compatibility with all the latest versions of the R packages that you have downloaded). To install R on your Windows computer, follow these steps: Go to https://cran.r-project.org/ Under “Download and Install R”, click on the “Windows” link. Under “Subdirectories”, click on the “base” link. On the next page, you should see a link saying something like “Download R 3.6.1 for Windows” (or R X.X.X, where X.X.X gives the version of R). Click on this link. You may be asked if you want to save or run a file “R-x.x.x-win32.exe”. Choose “Save” and save the file on the Desktop. Then double-click on the icon for the file to run it. You will be asked what language to install it in - choose English. The R Setup Wizard will appear in a window. Click “Next” at the bottom of the R Setup wizard window. The next page says “Information” at the top. Click “Next” again. The next page says “Select Destination Location” at the top. By default, it will suggest to install R in “C:Files” on your computer. Click “Next” at the bottom of the R Setup wizard window. The next page says “Select components” at the top. Click “Next” again. The next page says “Startup options” at the top. Click “Next” again. The next page says “Select start menu folder” at the top. Click “Next” again. The next page says “Select additional tasks” at the top. Click “Next” again. R should now be installing. This will take about a minute. When R has finished, you will see “Completing the R for Windows Setup Wizard” appear. Click “Finish”. To start R, you can do one of the following steps: Check if there is an “R” icon on the desktop of the computer that you are using. If so, double-click on the “R” icon to start R. If you cannot find an “R” icon, try the next step instead. Click on the “Start” button at the bottom left of your computer screen, and then choose “All programs”, and start R by selecting “R” (or R X.X.X, where X.X.X gives the version of R) from the menu of programs. The R console (a rectangle) should pop up: 3.2.2 How to install R on non-Windows computers (eg. Macintosh or Linux computers) These steps have not been checked as of 8/13/2019 so there may be small variations in what the prompts are. Installing are, however, is basically that same as any other program. Clicking “Yes” etc on everything should work. The instructions above are for installing R on a Windows PC. If you want to install R on a computer that has a non-Windows operating system (for example, a Macintosh or computer running Linux, you should download the appropriate R installer for that operating system at https://cran.r-project.org/ and follow the R installation instructions for the appropriate operating system at https://cran.r-project.org/doc/FAQ/R-FAQ.html#How-can-R-be-installed_003f . 3.3 Starting R To start R, Check if there is an “R” icon on the desktop of the computer that you are using. If so, double-click on the “R” icon to start R. If you cannot find an “R” icon, try the next step instead. You can also start R from the Start menu. Click on the “Start” button at the bottom left of your computer screen, and then choose “All programs”, and start R by selecting “R” (or R X.X.X, where X.X.X gives the version of R, eg. R 2.10.0) from the menu of programs. Say “Hi” to R and take a quick look at how it looks. Now say “Goodbye”, because we will never actually do any work in this version of R; instead, we’ll use the RStudio IDE (intregrated development environment). "],["downloading-rstudio.html", "Chapter 4 Downloading RStudio 4.1 Installing RStudio 4.2 Getting to know RStudio 4.3 RStudio versus RStudio Cloud", " Chapter 4 Downloading RStudio 4.1 Installing RStudio R is a programming language, and when you download it there is also a basic GUI (graphical user interface) that you can access via the R icon. A brief overview of installing RStudio can be found here “Getting RStudio on to your computer” 4.2 Getting to know RStudio For a brief overview of RStudio see “Getting started with RStudio” A good overview of what the different parts of RStudio can be seen in the image in this tweet: https://twitter.com/RLadiesNCL/status/1138812826917724160?s=20 4.3 RStudio versus RStudio Cloud RStudio and RStudio cloud work almost identially, so anything you read about RStudio will apply to RStudio Cloud. "],["installing-r-packages.html", "Chapter 5 Installing R packages 5.1 Downloading packages with the RStudio GUI 5.2 Downloading packages with the function install.packages() 5.3 Using packages after they are downloaded", " Chapter 5 Installing R packages R is a programming language, and packages or libraries are bundles of software build using R. Most sessions using R involve using additional R packages. NOTE: If you are working in an RStudio Cloud environment organized by someone else (eg a course instructor), they likely are taking care of many of the package management issues. The following information is still useful to be familiar with. 5.1 Downloading packages with the RStudio GUI There is a point-and-click interface for installing R packages in RStudio. There is a brief introduction to downloading packages on this site: http://web.cs.ucla.edu/~gulzar/rstudio/ I’ve summarized it here: \"Click on the Packages tab in the bottom-right section and then click on install. The following dialog box will appear “In the Install Packages dialog, write the package name you want to install under the Packages field and then click install. This will install the package you searched for or give you a list of matching package based on your package text.” 5.2 Downloading packages with the function install.packages() The easiest way to install a package if you know its name is to use the function install.packages(). Note that it might be better to call this “download.packages” since after you install it, you also have to load it! Frequently I will include install.packages(…) at the beginning of a lesson the first time we use a package to make sure the package is downloaded. Note, however, that if you already have downloaded the package, running install.packages(…) will download a new copy. We’ll download a package used for plotting called ggplot2, which stands for “Grammar of Graphics.” To download ggplot, run the following command: install.packages(&quot;ggplot2&quot;) Often when you download a package you’ll see a fair bit of red text, and sometime other things will pop up. Usually there’s nothing of interest here, but sometimes you need to read things carefully over it for hints about why something didn’t work. 5.3 Using packages after they are downloaded To actually make the functions in package accessible you need to use the library() command. Note that this is not in quotes. library(ggplot2) "],["installing-bioconductor.html", "Chapter 6 Installing Bioconductor 6.1 Bioconductor 6.2 Installing BiocManager", " Chapter 6 Installing Bioconductor 6.1 Bioconductor R packages (aka “libraries”) can live in many places. Most are accessed via CRAN, the Comprehensive R Archieve Network. The bioinformatics and computational biology community also has its own package hosting system called Bioconductor. NOTE: If you are working in an RStudio Cloud environment organized by someone else (eg a course instructor), they likely are taking care of most of package management issues, inlcuding setting up Bioconductor. The following information is still useful to be familiar with. To interface with Bioconductor you need the BiocManager package. The Bioconductor people have put BiocManager on CRAN to allow you to set up interactions with Bioconductor. Note that if you have an old version of R you will need to upate it to interact with bioconductor. 6.2 Installing BiocManager BiocManager can be installed using the install.packages() packages command. install.packages(&quot;BiocManager&quot;) Once downloaded, BioManager needs to be explicitly loaded into your active R session library(BiocManager) Individual packages can then be downloaded using the install() command. BiocManager::install(&quot;Biostrings&quot;) Bioconductor has many dependencies - other packages which is relies on. When you install Bioconductor packages you may need to update these packages. If something seems to not be working during this process, restart R and being the Bioconductor installation process until things seem to work. Again, to actually load the Biostrings package into your active R sessions requires the libary() command: library(Biostrings) For more information on BiocManager see the vignette: https://cran.r-project.org/web/packages/BiocManager/vignettes/BiocManager.html "],["brief-introduction-to-r.html", "Chapter 7 Brief introduction to R 7.1 Vocabulary 7.2 R functions etc 7.3 A brief introduction to R 7.4 Links and Further Reading", " Chapter 7 Brief introduction to R This chapter provides a brie introduction to R. At the end of are links to additional resources for getting started with R. 7.1 Vocabulary scalar vector list class numeric character assignmnet elements of an object indices attributes of an object arguement of a function 7.2 R functions etc &lt;- [ ] $ table() function c() log10() help(), ? help.search() RSiteSearch() mean() return() q() 7.3 A brief introduction to R You will type R commands into the RStudio console in order to carry out analyses in R. In the RStudio console you will see the R prompt starting with the symbol “&gt;”. “&gt;” will always be there at the beginning of each new command - don’t try to delete it. We type the commands needed for a particular task after this prompt. The command is carried out after you hit the Return key. Once you have started R, you can start typing in commands, and the results will be calculated immediately, for example: 2*3 ## [1] 6 Note that prior to the output of “6” it shows “[1]”. 10-3 ## [1] 7 Again, prior to the output of “7” it shows “[1]”. R can act like a basic calculator that you type command in to. You can also use it like a scientific calcualtor and create variables that store information. All variables (scalars, vectors, matrices, etc.) created by R are called objects. In R, we assign values to variables using an arrow. For example, we can assign the value 2*3 to the variable x using the command: x &lt;- 2*3 To view the contents of any R object, just type its name, and the contents of that R object will be displayed: x ## [1] 6 There are several possible different types of objects in R with fancy math names, including scalars, vectors, matrices, arrays, data frames, tables, and lists. The scalar variable x above is one example of an R object. While a scalar variable such as x has just one element, a vector consists of several elements. The elements in a vector are all of the same type (eg. numeric or characters), while lists may include elements such as characters as well as numeric quantities. To create a vector, we can use the c() (combine) function. For example, to create a vector called myvector that has elements with values 8, 6, 9, 10, and 5, we type: myvector &lt;- c(8, 6, 9, 10, 5) To see the contents of the variable myvector, we can just type its name and press enter myvector ## [1] 8 6 9 10 5 The [1] is the index of the first element in the vector. We can extract any element of the vector by typing the vector name with the index of that element given in square brackets. For example, to get the value of the 4th element in the vector myvector, we type: myvector[4] ## [1] 10 In contrast to a vector, a list can contain elements of different types, for example, both numeric and character elements. A list can also include other variables such as a vector. The list() function is used to create a list. For example, we could create a list mylist by typing: mylist &lt;- list(name=&quot;Fred&quot;, wife=&quot;Mary&quot;, myvector) We can then print out the contents of the list mylist by typing its name: mylist ## $name ## [1] &quot;Fred&quot; ## ## $wife ## [1] &quot;Mary&quot; ## ## [[3]] ## [1] 8 6 9 10 5 The elements in a list are numbered, and can be referred to using indices. We can extract an element of a list by typing the list name with the index of the element given in double square brackets (in contrast to a vector, where we only use single square brackets). Thus, we can extract the second and third elements from mylist by typing: mylist[c(2,3)] ## $wife ## [1] &quot;Mary&quot; ## ## [[2]] ## [1] 8 6 9 10 5 Elements of lists may also be named, and in this case the elements may be referred to by giving the list name, followed by “\\(”, followed by the element name. For example, mylist\\)name is the same as mylist[[1]] and mylist$wife is the same as mylist[[2]]: mylist$wife ## [1] &quot;Mary&quot; We can find out the names of the named elements in a list by using the attributes() function, for example: attributes(mylist) ## $names ## [1] &quot;name&quot; &quot;wife&quot; &quot;&quot; When you use the attributes() function to find the named elements of a list variable, the named elements are always listed under a heading “\\(names”. Therefore, we see that the named elements of the list variable mylist are called “name” and “wife”, and we can retrieve their values by typing mylist\\)name and mylist$wife, respectively. Another type of object that you will encounter in R is a table. For example, if we made a vector variable “mynames” containing the names of children in a class, we can use the table() function to produce a table variable that contains the number of children with each possible name: mynames &lt;- c(&quot;Mary&quot;, &quot;John&quot;, &quot;Ann&quot;, &quot;Sinead&quot;, &quot;Joe&quot;, &quot;Mary&quot;, &quot;Jim&quot;, &quot;John&quot;, &quot;Simon&quot;) Now make the table table(mynames) ## mynames ## Ann Jim Joe John Mary Simon Sinead ## 1 1 1 2 2 1 1 Note that there are two Johns and two Marys. We can store the table variable produced by the function table(), and call the stored table “mytable”, by typing: mytable &lt;- table(mynames) To access elements in a table variable, you need to use double square brackets, just like accessing elements in a list. For example, to access the fourth element in the table mytable (the number of children called “John”), we type: mytable[[4]] ## [1] 2 Alternatively, you can use the name of the fourth element in the table (“John”) to find the value of that table element: mytable[[&quot;John&quot;]] ## [1] 2 Functions in R usually require arguments, which are input variables (ie. objects) that are passed to them, which they then carry out some operation on. For example, the log10() function is passed a number, and it then calculates the log to the base 10 of that number: log10(100) ## [1] 2 In R, you can get help about a particular function by using the help() function. For example, if you want help about the log10() function, you can type: help(&quot;log10&quot;) When you use the help() function, a box or webpage will show up in one of the panes of RStudio with information about the function that you asked for help with. You can also use the ? next to the fuctnion ?log10 If you are not sure of the name of a function, but think you know part of its name, you can search for the function name using the help.search() and RSiteSearch() functions. The help.search() function searches to see if you already have a function installed (from one of the R packages that you have installed) that may be related to some topic you’re interested in. The RSiteSearch() function searches all R functions (including those in packages that you haven’t yet installed) for functions related to the topic you are interested in. For example, if you want to know if there is a function to calculate the standard deviation of a set of numbers, you can search for the names of all installed functions containing the word “deviation” in their description by typing: help.search(&quot;deviation&quot;) Among the functions that were found, is the function sd() in the “stats” package (an R package that comes with the standard R installation), which is used for calculating the standard deviation. In the example above, the help.search() function found a relevant function (sd() here). However, if you did not find what you were looking for with help.search(), you could then use the RSiteSearch() function to see if a search of all functions described on the R website may find something relevant to the topic that you’re interested in: RSiteSearch(&quot;deviation&quot;) The results of the RSiteSearch() function will be hits to descriptions of R functions, as well as to R mailing list discussions of those functions. We can perform computations with R using objects such as scalars and vectors. For example, to calculate the average of the values in the vector myvector (ie. the average of 8, 6, 9, 10 and 5), we can use the mean() function: mean(myvector) ## [1] 7.6 We have been using built-in R functions such as mean(), length(), print(), plot(), etc. We can also create our own functions in R to do calculations that you want to carry out very often on different input data sets. For example, we can create a function to calculate the value of 20 plus square of some input number: myfunction &lt;- function(x) { return(20 + (x*x)) } This function will calculate the square of a number (x), and then add 20 to that value. The return() statement returns the calculated value. Once you have typed in this function, the function is then available for use. For example, we can use the function for different input numbers (eg. 10, 25): myfunction(10) ## [1] 120 To quit R, type: q() 7.4 Links and Further Reading Some links are included here for further reading. For a more in-depth introduction to R, a good online tutorial is available on the “Kickstarting R” website, cran.r-project.org/doc/contrib/Lemon-kickstart. There is another nice (slightly more in-depth) tutorial to R available on the “Introduction to R” website, cran.r-project.org/doc/manuals/R-intro.html. Chapter 3 of Danielle Navarro’s book is an excellent intro to the basics of R. "],["introduction-to-ncbi-databases.html", "Chapter 8 Introduction to NCBI databases 8.1 To do 8.2 The NCBI Sequence Database 8.3 The NCBI Sub-Databases 8.4 Searching for an accession number in the NCBI database 8.5 NCBI Sequence Format (NCBI Format) 8.6 RefSeq 8.7 Querying the NCBI Database 8.8 Querying the NCBI Database via the NCBI Website (for reference) 8.9 Example: finding the sequences published in Nature 460:352-358 (for reference)", " Chapter 8 Introduction to NCBI databases By Avril Coglan, adapted by Nathan Brouwer This vignette provides an introduction to the general search features of the NCBI databases, including how to search by both accession numbers and other search parameters, such as specific papers. For example, if you don’t know the accession number of a sequence, you can locate it via a paper that worked on that sequence. 8.1 To do replicate searches in R using rentrez 8.2 The NCBI Sequence Database All published genome sequences are available over the internet, as it is a requirement of every scientific journal that any published DNA or RNA or protein sequence must be deposited in a public database. The main resources for storing and distributing sequence data are three large databases: the NCBI database (www.ncbi.nlm.nih.gov/), the *European Molecular Biology Laboratory (EMBL) database (https://www.ebi.ac.uk/ena), and the DNA Database of Japan (DDBJ)** database (www.ddbj.nig.ac.jp/). These databases collect all publicly available DNA, RNA and protein sequence data and make it available for free. They exchange data nightly, so contain essentially the same data. In this vignette we will discuss the NCBI database. Note however that it contains essentially the same data as in the EMBL/DDBJ databases. Sequences in the NCBI Sequence Database are identified by an accession number. This is a unique number that is only associated with one sequence. For example, the accession number NC_001477 is for the DEN-1 Dengue virus genome sequence. The accession number is what identifies the sequence. It is reported in scientific papers describing that sequence. As well as the sequence itself, for each sequence the NCBI database also stores some additional annotation data, such as the name of the species it comes from, references to publications describing that sequence, information on the structure of the protein, etc. Some of this annotation data was added by the person who sequenced a sequence and submitted it to the NCBI database, while some may have been added later by a human curator working for NCBI. 8.3 The NCBI Sub-Databases The NCBI database contains several sub-databases, the most important of which are: Nucleotide database: contains DNA and RNA sequences NCBI Protein database: contains protein sequences EST database: contains ESTs (expressed sequence tags), which are short sequences derived from mRNAs Genome database: contains DNA sequences for whole genomes PubMed: contains data on scientific publications 8.4 Searching for an accession number in the NCBI database The FASTA file format is a file format commonly used to store sequence information. The first line starts with the greater than character followed by a name and/or description for the sequence. Subsequent lines contain the sequence itself. ## &gt;mysequence1 ## ACATGAGACAGACAGACCCCCAGAGACAGACCCCTAGACACAGAGAGAG ## TATGCAGGACAGGGTTTTTGCCCAGGGTGGCAGTATG A FASTA file can contain more than one sequence. If a FASTA file contains many sequences, then for each sequence it will have a header line starting with greater than character followed by the sequence itself. ## &gt;mysequence1 ## ACATGAGACAGACAGACCCCCAGAGACAGACCCCTAGACACAGAGAGAG ## TATGCAGGACAGGGTTTTTGCCCAGGGTGGCAGTATG ## ## &gt;mysequence2 ## AGGATTGAGGTATGGGTATGTTCCCGATTGAGTAGCCAGTATGAGCCAG ## AGTTTTTTACAAGTATTTTTCCCAGTAGCCAGAGAGAGAGTCACCCAGT ## ACAGAGAGC 8.5 NCBI Sequence Format (NCBI Format) As mentioned above, for each sequence the NCBI database stores some extra information such as the species that it came from, publications describing the sequence, etc. This information is stored in the NCBI entry or NCBI record for the sequence. The NCBI entry for a sequence can be viewed by searching the NCBI database for the accession number for that sequence. The NCBI entries for sequences are stored in a particular format, known as NCBI format. To view the NCBI entry for the DEN-1 Dengue virus (which has accession NC_001477), follow these steps: Go to the NCBI website (www.ncbi.nlm.nih.gov). Search for the accession number. On the results page, if your sequence corresponds to a nucleotide (DNA or RNA) sequence, you should see a hit in the Nucleotide database, and you should click on the word “Nucleotide” to view the NCBI entry for the hit. Likewise, if your sequence corresponds to a protein sequence, you should see a hit in the Protein database, and you should click on the word “Protein” to view the NCBI entry for the hit. After you click on “Nucleotide” or “Protein” in the previous step, the NCBI entry for the accession will appear. The NCBI entry for an accession contains a lot of information about the sequence, such as papers describing it, features in the sequence, etc. The DEFINITION field gives a short description for the sequence. The ORGANISM field in the NCBI entry identifies the species that the sequence came from. The REFERENCE field contains scientific publications describing the sequence. The FEATURES field contains information about the location of features of interest inside the sequence, such as regulatory sequences or genes that lie inside the sequence. The ORIGIN field gives the sequence itself. 8.6 RefSeq When carrying out searches of the NCBI database, it is important to bear in mind that the database may contain redundant sequences for the same gene that were sequenced by different laboratories (because many different labs have sequenced the gene, and submitted their sequences to the NCBI database). There are also many different types of nucleotide sequences and protein sequences in the NCBI database. With respect to nucleotide sequences, some many be entire genomic DNA sequences, some may be mRNAs, and some may be lower quality sequences such as expressed sequence tags (ESTs, which are derived from parts of mRNAs), or DNA sequences of contigs from genome projects. That is, you can end up with an entry in the protein database based on sequence derived from a genomic sequence, from sequencing just the gene, and from other routes. Furthermore, some sequences may be manually curated so that the associated entries contain extra information, but the majority of sequences are uncurated. As mentioned above, the NCBI database often contains redundant information for a gene, contains sequences of varying quality, and contains both uncurated and curated data. As a result, NCBI has made a special database called RefSeq (reference sequence database), which is a subset of the NCBI database. The data in RefSeq is manually curated, is high quality sequence data, and is non-redundant; this means that each gene (or splice-form / isoform of a gene, in the case of eukaryotes), protein, or genome sequence is only represented once. The data in RefSeq is curated and is of much higher quality than the rest of the NCBI Sequence Database. However, unfortunately, because of the high level of manual curation required, RefSeq does not cover all species, and is not comprehensive for the species that are covered so far. To speed up searches and simplify the results in to can be very useful to just search RefSeq. However, for detailed and thorough work the full database should probably be searched and the results scrutinized. You can easily tell that a sequence comes from RefSeq because its accession number starts with particular sequence of letters. That is, accessions of RefSeq sequences corresponding to protein records usually start with NP_, and accessions of RefSeq curated complete genome sequences usually start with NC_ or NS_. 8.7 Querying the NCBI Database You may need to interrogate the NCBI Database to find particular sequences or a set of sequences matching given criteria, such as: The sequence with accession NC_001477 The sequences published in Nature 460:352-358 All sequences from Chlamydia trachomatis Sequences submitted by Caroline Cameron, a syphyllis researcher Flagellin or fibrinogen sequences The glutamine synthetase gene from Mycobacteriuma leprae Just the upstream control region of the Mycobacterium leprae dnaA gene The sequence of the Mycobacterium leprae DnaA protein The genome sequence of syphilis, Treponema pallidum subspp. pallidum All human nucleotide sequences associated with malaria There are two main ways that you can query the NCBI database to find these sets of sequences. The first possibility is to carry out searches on the NCBI website. The second possibility is to carry out searches from R using one of several packages that can interface with NCBI. As of October 2019 rentrez seems to be the best package for this.. Below, I will explain how to manually carry out queries on the NCBI database. 8.8 Querying the NCBI Database via the NCBI Website (for reference) NOTE: The following section is here for reference; you need to know its possible to refine searches but do not need to know any of these actual tags. If you are carrying out searches on the NCBI website, to narrow down your searches to specific types of sequences or to specific organisms, you will need to use “search tags”. For example, the search tags “[PROP]” and “[ORGN]” let you restrict your search to a specific subset of the NCBI Sequence Database, or to sequences from a particular taxon, respectively. Here is a list of useful search tags, which we will explain how to use below: [AC] NC_001477[AC] With a particular accession number [ORGN] Fungi[ORGN] From a particular organism or taxon [PROP] biomol_mRNA[PROP] Of a specific type (eg. mRNA) or from a specific database (eg. RefSeq) [JOUR] Nature[JOUR] Described in a paper published in a particular journal [VOL] 531[VOL] Described in a paper published in a particular journal volume [PAGE] 27[PAGE] Described in a paper with a particular start-page in a journal [AU] “Smith J”[AU] Described in a paper, or submitted to NCBI, by a particular author To carry out searches of the NCBI database, you first need to go to the NCBI website, and type your search query into the search box at the top. For example, to search for all sequences from Fungi, you would type “Fungi[ORGN]” into the search box on the NCBI website. You can combine the search tags above by using “AND”, to make more complex searches. For example, to find all mRNA sequences from Fungi, you could type “Fungi[ORGN] AND biomol_mRNA[PROP]” in the search box on the NCBI website. Likewise, you can also combine search tags by using “OR”, for example, to search for all mRNA sequences from Fungi or Bacteria, you would type “(Fungi[ORGN] OR Bacteria[ORGN]) AND biomol_mRNA[PROP]” in the search box. Note that you need to put brackets around “Fungi[ORGN] OR Bacteria[ORGN]” to specify that the word “OR” refers to these two search tags. Here are some examples of searches, some of them made by combining search terms using “AND”: NC_001477[AC] - With accession number NC_001477 Nature[JOUR] AND 460[VOL] AND 352[PAGE] - Published in Nature 460:352-358 “Chlamydia trachomatis”[ORGN] - From the bacterium Chlamydia trachomatis “Berriman M”[AU] - Published in a paper, or submitted to NCBI, by M. Berriman flagellin OR fibrinogen - Which contain the word “flagellin” or “fibrinogen” in their NCBI record “Mycobacterium leprae”[ORGN] AND dnaA - Which are from M. leprae, and contain “dnaA” in their NCBI record “Homo sapiens”[ORGN] AND “colon cancer” - Which are from human, and contain “colon cancer” in their NCBI record “Homo sapiens”[ORGN] AND malaria - Which are from human, and contain “malaria” in their NCBI record “Homo sapiens”[ORGN] AND biomol_mrna[PROP] - Which are mRNA sequences from human “Bacteria”[ORGN] AND srcdb_refseq[PROP] - Which are RefSeq sequences from Bacteria “colon cancer” AND srcdb_refseq[PROP] - From RefSeq, which contain “colon cancer” in their NCBI record Note that if you are searching for a phrase such as “colon cancer” or “Chlamydia trachomatis”, you need to put the phrase in quotes when typing it into the search box. This is because if you type the phrase in the search box without quotes, the search will be for NCBI records that contain either of the two words “colon” or “cancer” (or either of the two words “Chlamydia” or “trachomatis”), not necessarily both words. As mentioned above, the NCBI database contains several sub-databases, including the NCBI Nucleotide database and the NCBI Protein database. If you go to the NCBI website, and type one of the search queries above in the search box at the top of the page, the results page will tell you how many matching NCBI records were found in each of the NCBI sub-databases. For example, if you search for “Chlamydia trachomatis[ORGN]”, you will get matches to proteins from C. trachomatis in the NCBI Protein database, matches to DNA and RNA sequences from C. trachomatis in the NCBI Nucleotide database, matches to whole genome sequences for C. trachomatis strains in the NCBI Genome database, and so on: Alternatively, if you know in advance that you want to search a particular sub-database, for example, the NCBI Protein database, when you go to the NCBI website, you can select that sub-database from the drop-down list above the search box, so that you will search that sub-database. 8.9 Example: finding the sequences published in Nature 460:352-358 (for reference) NOTE: The following section is here for reference; you need to know its possible to refine searches but do not need to know any of these actual tags. For example, if you want to find sequences published in Nature 460:352-358, you can use the “[JOUR]”, “[VOL]” and “[PAGE]” search terms. That is, you would go to the NCBI website and type in the search box on the top: “Nature”[JOUR] AND 460[VOL] AND 352[PAGE], where [JOUR] specifies the journal name, [VOL] the volume of the journal the paper is in, and [PAGE] the page number. This should bring up a results page with “50890” beside the word “Nucleotide”, and “1” beside the word “Genome”, and “25701” beside the word “Protein”, indicating that there were 50890 hits to sequence records in the Nucleotide database, which contains DNA and RNA sequences, and 1 hit to the Genome database, which contains genome sequences, and 25701 hits to the Protein database, which contains protein sequences. If you click on the word “Nucleotide”, it will bring up a webpage with a list of links to the NCBI sequence records for those 50890 hits. The 50890 hits are all contigs from the schistosome worm Schistosoma mansoni. Likewise, if you click on the word “Protein”, it will bring up a webpage with a list of links to the NCBI sequence records for the 25701 hits, and you will see that the hits are all predicted proteins for Schistosoma mansoni. If you click on the word “Genome”, it will bring you to the NCBI record for the Schistosoma mansoni genome sequence, which has NCBI accession NS_00200. Note that the accession starts with “NS_”, which indicates that it is a RefSeq accession. Therefore, in Nature volume 460, page 352, the Schistosoma mansoni genome sequence was published, along with all the DNA sequence contigs that were sequenced for the genome project, and all the predicted proteins for the gene predictions made in the genome sequence. You can view the original paper on the Nature website at http://www.nature.com/nature/journal/v460/n7253/abs/nature08160.html. Note: Schistmosoma mansoni is a parasitic worm that is responsible for causing schistosomiasis, which is classified by the WHO as a neglected tropical disease. "],["downloading-ncbi-sequence-data-by-hand.html", "Chapter 9 Downloading NCBI sequence data by hand 9.1 Retrieving genome sequence data via the NCBI website", " Chapter 9 Downloading NCBI sequence data by hand By Avril Coglan, adapted by Nathan Brouwer The following vignette was originally written by Avril Coghlan. It provides brief, basic information for how to access sequences via the internet. A subsequent vignette provides more details. 9.1 Retrieving genome sequence data via the NCBI website You can easily retrieve DNA or protein sequence data by hand from the NCBI Sequence Database via its website www.ncbi.nlm.nih.gov. Dengue DEN-1 DNA is a viral DNA sequence and its NCBI accession is NC_001477. To retrieve the DNA sequence for the Dengue DEN-1 virus from NCBI, go to the NCBI website, type “NC_001477” in the Search box at the top of the webpage, and press the “Search” button beside the Search box. (While this is the normal workflow, accessions related well-known organisms can sometimes turn up using a direct Google search. This is the case for NC_001477 - if you Google it you can go directly to the website with the genome sequence: https://www.ncbi.nlm.nih.gov/nuccore/NC_001477). On the results page of a normal NCBI search you will see the number of hits to “NC_001477” in each of the NCBI databases on the NCBI website. There are many databases on the NCBI website, for example, the PubMed and Pubmed Central data contain abstracts from scientific papers, the Genes and Genomes database contains DNA and RNA sequence data, the Proteins database contains protein sequence data, and so on. Most people would do this by hand, but it can also be done via R using the rentrez package. In this tutorial we’ll focus on the web interface. Its good to remember, though, that almost anything done via the webpage can be automated using an R script. As you are looking for the DNA sequence of the Dengue DEN-1 virus genome, you expect to see a hit in the NCBI Nucleotide database. This is indicated at the top of the page where it says “NUCLEOTIDE SEQUENCE” and lists “Dengue virus 1, complete genome.” When you click on the link for the Nucleotide database, it will bring you to the record for NC_001477 in the NCBI Nucleotide database. This will contain the name and NCBI accession of the sequence, as well as other details such as any papers describing the sequence. If you scroll down you’ll see the sequence also. If you need it, you can retrieve the DNA sequence for the DEN-1 Dengue virus genome sequence as a FASTA format sequence file in a couple ways. The easiest is just to copy and paste it into a text, .R, or other file. You can also click on “Send to” at the top right of the NC_001477 sequence record webpage (just to the left of the side bar; its kinda small). After you click on Send to you can pick several options. and then choose “File” in the menu that appears, and then choose FASTA from the “Format” menu that appears, and click on “Create file”. The sequence will then download. The default file name is sequence.fasta so you’ll probably want to change it. You can now open the FASTA file containing the DEN-1 Dengue virus genome sequence using a text editor like Notepad, WordPad, Notepad++, or even RStudio on your computer. To find a text editor on your computer search for “text” from the start menu (Windows) and usually one will come up. (Opening the file in a word processor like word isn’t recommended). "],["downloading-sequences-from-uniprot-by-hand.html", "Chapter 10 Downloading sequences from UniProt by hand 10.1 Vocab 10.2 UniProt 10.3 Viewing the UniProt webpage for a protein sequence 10.4 Retrieving a UniProt protein sequence via the UniProt website", " Chapter 10 Downloading sequences from UniProt by hand The following information was modified and updated from Coghlan’s “Pairwise Sequence Alignment: UniProt” https://a-little-book-of-r-for-bioinformatics.readthedocs.io/en/latest/src/chapter4.html The original online version has images, though they are somewhat outdated. 10.1 Vocab RefSeq manual curation UniProt accession 10.2 UniProt In a previous vignette you learnt how to retrieve sequences from the NCBI database. The NCBI database is a key database in bioinformatics because it contains essentially all DNA sequences ever sequenced. As mentioned previously, a subsection of the NCBI database called RefSeq consists of high quality DNA and protein sequence data. Furthermore, the NCBI entries for the RefSeq sequences have been manually curated, which means that expert biologists employed by NCBI have added additional information to the NCBI entries for those sequences, such as details of scientific papers that describe the sequences. Another extremely important manually curated database is UniProt, which focuses on protein sequences. UniProt aims to contains manually curated information on all known protein sequences. While many of the protein sequences in UniProt are also present in RefSeq, the amount and quality of manually curated information in UniProt is much higher than that in RefSeq. For each protein in UniProt, the UniProt curators read all the scientific papers that they can find about that protein, and add information from those papers to the protein’s UniProt entry. For example, for a human protein, the UniProt entry for the protein usually includes information about the biological function of the protein, in what human tissues it is expressed, whether it interacts with other human proteins, and much more. All this information has been manually gathered by the UniProt curators from scientific papers, and the papers in which the found the information are always listed in the UniProt entry for the protein. Just like NCBI, UniProt also assigns an accession to each sequence in the UniProt database. Although the same protein sequence may appear in both the NCBI database and the UniProt database, it will have different NCBI and UniProt accessions. However, there is usually a link on the NCBI entry for the protein sequence to the UniProt entry, and vice versa. 10.3 Viewing the UniProt webpage for a protein sequence If you are given the UniProt accession for a protein, to find the UniProt entry for the protein, you first need to go the UniProt website, www.uniprot.org. At the top of the UniProt website, you will see a search box, and you can type the accession of the protein that you are looking for in this search box, and then click on the “Search” button to search for it. For example, if you want to find the sequence for the chorismate lyase protein from Mycobacterium leprae (the bacterium which causes leprosy), which has UniProt accession Q9CD83, you would type just “Q9CD83” in the search box and press “Search”. The UniProt entry for UniProt accession Q9CD83 will then appear in your web browser. Beside the heading “Organism” you can see the organism is given as Mycobacterium leprae. If you scroll down you’ll find a section Names and Taxonomy and beside the heading “Taxonomic lineage”, you can see “Bacteria - Actinobacteria - Actinobacteridae - Actinomycetales - Corynebacterineae - Mycobacteriaceae- Mycobacterium”. This tells us that Mycobacterium is a species of bacteria, which belongs to a group of related bacteria called the Mycobacteriaceae, which itself belongs to a larger group of related bacteria called the Corynebacterineae, which itself belongs to an even larger group of related bacteria called the Actinomycetales, which itself belongs to the Actinobacteridae, which itself belongs to a huge group of bacteria called the Actinobacteria. 10.3.1 Protein function Back up at the top under “organism” is says “Status”, which tells us the annotation score is 2 out of 5, that it is a “Protein inferred from homology”, which means what we know about it is derived from bioinformatics and computational tools, not lab work. Beside the heading “Function”, it says that the function of this protein is that it “Removes the pyruvyl group from chorismate to provide 4-hydroxybenzoate (4HB)”. This tells us this protein is an enzyme (a protein that increases the rate of a specific biochemical reaction), and tells us what is the particular biochemical reaction that this enzyme is involved in. At the end of this info it says “By similarity”, which again indicates that what we know about this protein comes from bioinformatics, not lab work. 10.3.2 Protein sequence and size Under Sequence we see that the sequence length is 210 amino acids long (210 letters long) and has a mass of 24,045 daltons. We can access the sequence as a FASTA file from here if we want and also carry out a BLAST search from a link on the right. 10.3.3 Other information Further down the UniProt page for this protein, you will see a lot more information, as well as many links to webpages in other biological databases, such as NCBI. The huge amount of information about proteins in UniProt means that if you want to find out about a particular protein, the UniProt page for that protein is a great place to start. 10.4 Retrieving a UniProt protein sequence via the UniProt website There are a couple different ways to retrieve the sequence. At the top of the page is a tab that say “Format” which brings you to a page with th FASTA file. You can copy and paste the sequence from here if you want. To save it as a file, go to the “File” menu of your web browser, choose “Save page as”, and save the file. Remember to give the file a sensible name (eg. “Q9CD83.fasta” for accession Q9CD83), and in a place that you will remember (eg. in the “My Documents” folder). For example, you can retrieve the protein sequences for the chorismate lyase protein from Mycobacterium leprae (which has UniProt accession Q9CD83) and for the chorismate lyase protein from Mycobacterium ulcerans (UniProt accession A0PQ23), and save them as FASTA-format files (eg. “Q9CD83.fasta” and “A0PQ23.fasta”, as described above. You can also put the UniProt information into an online Basket. If you do this for both Q9CD83 and A0PQ23 you can think click on Basket, select both entries, and carry out a pairwise alignment by clicking on Align. Mycobacterium leprae is the bacterium which causes leprosy, while Mycobacterium ulcerans is a related bacterium which causes Buruli ulcer, both of which are classified by the WHO as neglected tropical diseases. The M. leprae and M. ulcerans chorismate lyase proteins are an example of a pair of homologous (related) proteins in two related species of bacteria. If you downloaded the protein sequences for UniProt accessions Q9CD83 and A0PQ23 and saved them as FASTA-format files (eg. “Q9CD83.fasta” and “A0PQ23.fasta”), you could read them into R using the read.fasta() function in the SeqinR R package (as detailed in another Vignette) or a similar function from another package. Note that the read.fasta() function normally expects that you have put your FASTA-format files in the the working directory of R. For convenience so you can explore these sequences they have been saved in a special folder in the dayoff package and can be accessed like this for the Leprosy sequence # load dayoff library(dayoff) # locate the file within the package using system.file() file.1 &lt;- system.file(&quot;./extdata/Q9CD83.fasta&quot;,package = &quot;dayoff&quot;) # load seqinr library(&quot;seqinr&quot;) # load fasta leprae &lt;- read.fasta(file = file.1) lepraeseq &lt;- leprae[[1]] We can confirm str(lepraeseq) For the other sequence # locate the file within the package using system.file() file.1 &lt;- system.file(&quot;./extdata/A0PQ23.fasta&quot;,package = &quot;dayoff&quot;) # load fasta ulcerans &lt;- read.fasta(file = &quot;A0PQ23.fasta&quot;) ulceransseq &lt;- ulcerans[[1]] "],["sequence-databases.html", "Chapter 11 Sequence Databases 11.1 Querying the NCBI Database via R 11.2 Summary 11.3 Acknowledgements", " Chapter 11 Sequence Databases 11.1 Querying the NCBI Database via R Instead of carrying out searches of the NCBI database on the NCBI website, you can carry out searches directly from R by using the SeqinR R package. It is possible to use the SeqinR R package to retrieve sequences from these databases. The SeqinR package was written by the group that created the ACNUC database in Lyon, France (http://pbil.univ-lyon1.fr/databases/acnuc/acnuc.html). The ACNUC database is a database that contains most of the data from the NCBI Sequence Database, as well as data from other sequence databases such as UniProt and Ensembl. An advantage of the ACNUC database is that it brings together data from various different sources, and makes it easy to search, for example, by using the SeqinR R package. As will be explained below, the ACNUC database is organised into various different ACNUC (sub)-databases, which contain different parts of the NCBI database, and when you want to search the NCBI database via R, you will need to specify which ACNUC sub-database the NCBI data that you want to query is stored in. To obtain a full list of the ACNUC sub-databases that you can access using SeqinR, you can use the “choosebank()” function from SeqinR: library(“seqinr”) # Load the SeqinR R package choosebank() # List all the sub-databases in ACNUC [1] “genbank” “embl” “emblwgs” “swissprot” [5] “ensembl” “hogenom” “hogenomdna” “hovergendna” [9] “hovergen” “hogenom4” “hogenom4dna” “homolens” [13] “homolensdna” “hobacnucl” “hobacprot” “phever2” [17] “phever2dna” “refseq” “nrsub” “greviews” [21] “bacterial” “protozoan” “ensbacteria” “ensprotists” [25] “ensfungi” “ensmetazoa” “ensplants” “mito” [29] “polymorphix” “emglib” “taxobacgen” “refseqViruses” Alas, the ACNUC sub-databases do not have a one-to-one correspondence with the NCBI sub-databases (the NCBI Protein database, NCBI EST database, NCBI Genome database, etc.)! Three of the most important sub-databases in ACNUC which can be searched from R are: “genbank”: this contains DNA and RNA sequences from the NCBI Sequence Database, except for certain classes of sequences (eg. draft genome sequence data from genome sequencing projects) “refseq”: this contains DNA and RNA sequences from Refseq, the curated part of the NCBI Sequence Database “refseqViruses”: this contains DNA, RNA and proteins sequences from viruses from RefSeq You can find more information about what each of these ACNUC databases contains by looking at the ACNUC website. You can carry out complex queries using the “query()” function from the SeqinR package. If you look at the help page for the query() function (by typing “help(query)”, you will see that it allows you to specify criteria that you require the sequences to fulfill. For example, to search for a sequence with a particular NCBI accession, you can use the “AC=” argument in “query()”. The “query()” function will then search for sequences in the NCBI Sequence Database that match your criteria. Just as you can use “AC=” to specify an accession in a search, you can specify that you want to find sequences whose NCBI records contain a certain keywords by using “K=” as an argument (input) to the “query()” function. Likewise you can limit a search to either DNA or mRNA sequences by using the “M=” argument for the “query()” function. Here are some more possible arguments you can use in the “query()” function: Argument Example Restricts your search to sequences: “AC=” “AC=NC_001477” With a particular accession number “SP=” “SP=Chlamydia” From a particular organism or taxon “M=” “M=mRNA” Of a specific type (eg. mRNA) “J=” “J=Nature” Described in a paper published in a particular journal “R=” “R=Nature/460/352” Described in a paper in a particular journal, volume and start-page “AU=” “AU=Smith” Described in a paper, or submitted to NCBI, by a particular author The full list of possible arguments for the “query()” funtion are given on its help page. Here are some examples using the query function: Input to the query() function Searches for sequences: “AC=NC_001477” With accession number NC_001477 “R=Nature/460/352” Published in Nature 460:352-358 “SP=Chlamydia trachomatis” From the bacterium Chlamydia trachomatis “AU=Berriman” Published in a paper, or submitted to NCBI, by someone called Berriman “K=flagellin OR K=fibrinogen” Which have the keyword ‘flagellin’ or ‘fibrinogen’ “SP=Mycobacterium leprae AND K=dnaA” Which are from M. leprae, and have the keyword “dnaA” “SP=Homo sapiens AND K=colon cancer” Which are from human, and have the keyword “colon cancer” “SP=Homo sapiens AND K=malaria” Which are from human, and have the keyword “malaria” “SP=Homo sapiens AND M=mrna” Which are mRNA sequences from human “SP=Bacteria” Which are sequences from Bacteria As explained above, the ACNUC database contains the NCBI sequence data organised into several sub-databases, and you can view the list of those sub-databases by using the “choosebank()” function from the SeqinR package. When you want to use “query()” to carry out a particular sub-database (eg. “genbank”, which contains DNA and RNA sequences from the NCBI Sequence Database), you need to first specify the database that you want to search by using the “choosebank()” function, for example: choosebank(“genbank”) # Specify that we want to search the ‘genbank’ ACNUC sub-database Likewise, to specify that we want to search the ‘refseq’ ACNUC sub-database, which contains sequences from the NCBI RefSeq database, we would type: choosebank(“refseq”) # Specify that we want to search the ‘refseq’ ACNUC sub-database Once you have specified which ACNUC sub-database you want to search, you can carry out a search of that sub-database by using the “query()” function. You need to pass the “query()” function both a name for your query (which you can make up), and the query itself (which will be in the format of the examples in the table above). For example, if we want to search for RefSeq sequences from Bacteria, we might decide to call our query “RefSeqBact”, and we would call the “query()” function as follows: query(“RefSeqBact”, “SP=Bacteria”) As explained below, the results of the search are stored in a list variable called “RefSeqBact”, and can be retrieved from that list variable. The last thing to do once you have completed your search is to close the connection to the ACNUC sub-database that you were searching, by typing: closebank() Thus, there are three steps involved in carrying out a query using SeqinR: first use “choosebank()” to select the ACNUC sub-database to search, secondly use “query()” to query the database, and thirdly use “closebank()” to close the connection to the ACNUC sub-database. Another example could be to search for mRNA sequences from the parasitic worm Schistosoma mansoni in the NCBI Nucleotide database. The appropriate ACNUC sub-database to search is the “genbank” ACNUC sub-database. We may decide to call our search “SchistosomamRNA”. Therefore, to carry out the search, we type in R: choosebank(“genbank”) query(“SchistosomamRNA”, “SP=Schistosoma mansoni AND M=mrna”) closebank() Example: finding the sequence for the DEN-1 Dengue virus genome Another example could be to search for the DEN-1 Dengue virus genome sequence, which has accession NC_001477. This is a viral genome sequence, and so should be in the ACNUC sub-database “refSeqViruses”. Thus to search for this sequence, calling our search “Dengue1”, we type in R: choosebank(“refseqViruses”) query(“Dengue1”, “AC=NC_001477”) The result of the search is now stored in the list variable Dengue1. Remember that a list is an R object that is like a vector, but can contain elements that are numeric and/or contain characters. In this case, the list Dengue1 contains information on the NCBI records that match the query (ie. information on the NCBI record for accession NC_001477). If you look at the help page for “query()”, the details of the arguments are given under the heading “Arguments”, and the details of the results (outputs) are given under the heading “Value”. If you read this now, you will see that it tells us that the result of the “query()” function is a list with six different named elements, named “call”, “name”, “nelem”, “typelist”, “req”, and “socket”. The content of each of these six named elements is explained, for example, the “nelem” element contains the number of sequences that match the query, and the “req” element contains their accession numbers. In our example, the list object Dengue1 is an output of the “query()” function, and so has each of these six named elements, as we can find out by using the “attributes()” function, and looking at the named elements listed under the heading “$names”: attributes(Dengue1) $names [1] “call” “name” “nelem” “typelist” “req” “socket” \\(class [1] &quot;qaw&quot; As explained in the brief introduction to R, we can retrieve the value for each of the named elements in the list Dengue1 by using “\\)”, followed by the element’s name, for example, to get the value of the element named “nelem” in the list Dengue1, we type: Dengue1$nelem [1] 1 This tells us that there was one sequence in the ‘refseqViruses’ ACNUC database that matched the query. This is what we would expect, as there should only be one sequence corresponding to accession NC_001477. To obtain the accession numbers of the sequence found, we can type: Dengue1$req [[1]] name length frame ncbicg “NC_001477” “10735” “0” “1” As expected, the accession number of the matching sequence is NC_001477. When you type “attributes(Dengue1)” you can see that there are two headings, “\\(names”, and “\\)class”. As explained above, the named elements of the list variable Dengue1 are listed under the heading “\\(names”. In fact, the headings “\\)names” and “\\(class” are two attributes of the list variable Dengue1. We can retrieve the values of the attributes of a variable using the “attr()” function. For example, to retrieve the value of the attribute “\\)names” of Dengue1, we type: attr(Dengue1, “names”) [1] “call” “name” “nelem” “typelist” “req” “socket” This gives us the value of the attribute “\\(names”, which contains the the names of the named elements of the list variable Dengue1. Similarly, we can retrieve the value of the a attribute “\\)class” of Dengue1, we type: attr(Dengue1, “class”) [1] “qaw” This tells us that the value of the attribute “$class” is “qaw”. The final step in retrieving a genomic DNA sequence is to use the “getSequence()” function to tell R to retrieve the sequence data. The command below uses “getSequence()” to retrieve the sequence data for the DEN-1 Dengue virus genome, and puts the sequence into a variable dengueseq: dengueseq &lt;- getSequence(Dengue1\\(req[[1]]) Note that the input to the getSequence() command is Dengue1\\)req[[1]], which contains the name of the NCBI record that the list Dengue1 contains information about. Once you have retrieved a sequence, you can then print it out. The variable dengueseq is a vector containing the nucleotide sequence. Each element of the vector contains one nucleotide of the sequence. Therefore, we can print out the first 50 nucleotides of the DEN-1 Dengue genome sequence by typing: dengueseq[1:50] [1] “a” “g” “t” “t” “g” “t” “t” “a” “g” “t” “c” “t” “a” “c” “g” “t” “g” “g” “a” [20] “c” “c” “g” “a” “c” “a” “a” “g” “a” “a” “c” “a” “g” “t” “t” “t” “c” “g” “a” [39] “a” “t” “c” “g” “g” “a” “a” “g” “c” “t” “t” “g” Note that dengueseq[1:50] refers to the elements of the vector dengueseq with indices from 1-50. These elements contain the first 50 nucleotides of the DEN-1 Dengue virus genome sequence. As well as retrieving the DNA (or RNA or protein) sequence itself, SeqinR can also retrieve all the annotations for the sequence, for example, information on when the sequence was sequenced, who sequenced it, what organism is it from, what paper was it described in, what genes were identified in the sequence, and so on. Once you have retrieved a sequence using SeqinR, you can retrieved its annotations by using the “getAnnot()” function. For example, to view the annotations for the DEN-1 Dengue virus genome sequence, we type: annots &lt;- getAnnot(Dengue1$req[[1]]) This stores the annotations information from the NCBI record for the DEN-1 Dengue virus sequence in a vector variable annots, with one line of the NCBI record in each element of the vector. Therefore, we can print out the first 20 lines of the NCBI record by typing: annots[1:20] [1] “LOCUS NC_001477 10735 bp ss-RNA linear VRL 08-DEC-2008” [2] “DEFINITION Dengue virus type 1, complete genome.” [3] “ACCESSION NC_001477” [4] “VERSION NC_001477.1 GI:9626685” [5] “DBLINK Project: 15306” [6] “KEYWORDS .” [7] “SOURCE Dengue virus 1” [8] \" ORGANISM Dengue virus 1\" [9] \" Viruses; ssRNA positive-strand viruses, no DNA stage; Flaviviridae;\" [10] \" Flavivirus; Dengue virus group.\" [11] “REFERENCE 1 (bases 1 to 10735)” [12] \" AUTHORS Puri,B., Nelson,W.M., Henchal,E.A., Hoke,C.H., Eckels,K.H.,\" [13] \" Dubois,D.R., Porter,K.R. and Hayes,C.G.\" [14] \" TITLE Molecular analysis of dengue virus attenuation after serial passage\" [15] \" in primary dog kidney cells\" [16] \" JOURNAL J. Gen. Virol. 78 (PT 9), 2287-2291 (1997)\" [17] \" PUBMED 9292016\" [18] “REFERENCE 2 (bases 1 to 10735)” [19] \" AUTHORS McKee,K.T. Jr., Bancroft,W.H., Eckels,K.H., Redfield,R.R.,\" [20] \" Summers,P.L. and Russell,P.K.\" On the left of the annotations, you will see that there is a column containing the field name. For example, the line of the with “ACCESSION” in the left column is the accession field, which contains the accession for the sequence (NC_001477 for the DEN-1 Dengue virus). The line with “ORGANISM” in the left column is the organism field, and usually contains the Latin name for the organism (“Dengue virus 1” here). The line with “AUTHORS” in the left column is the authors field, and contain the names of authors that wrote papers to describe the sequence and/or the names of the people who submitted the sequence to the NCBI Database. When you have finished your running your query and getting the corresponding sequences and annotations, close the connection to the ACNUC sub-database: closebank() Example: finding the sequences published in Nature 460:352-358 We described above how to search for the sequences published in Nature 460:352-358, using the NCBI website. A second method is to use the SeqinR R package to search the ACNUC databases (which contain the NCBI sequence data) from R. If you look at the help page the “query()” function, you see that you can query for sequences published in a particular paper using R=refcode, specifying the reference as refcode such as in jcode/volume/page (e.g., JMB/13/5432 or R=Nature/396/133). For the paper Nature 460:352-358, we would need to use the refcode ‘R=Nature/460/352’. First we need to specify which of the ACNUC databases we want to search. For example, to specify that we want to search the “genbank” ACNUC database, which contains DNA and RNA sequences from the NCBI Nucleotide database, we type: choosebank(“genbank”) # Specify that we want to search the ‘genbank’ ACNUC sub-database We can then search the ‘genbank’ database for sequences that match a specific set of criteria by using the “query()” function. For example, to search for sequences that were published in Nature 460:352-358, we type: query(‘naturepaper’, ‘R=Nature/460/352’) The line above tells R that we want to store the results of the query in an R list variable called naturepaper. To get the value of the element named “nelem” in the list naturepaper, we type: naturepaper$nelem [1] 19022 This tells us that there were 19022 sequences in the ‘genbank’ ACNUC database that matched the query. The ‘genbank’ ACNUC database contains DNA or RNA sequences from the NCBI Nucleotide database. Why don’t we get the same number of sequences as found by carrying out the search on the NCBI website (where we found 50890 hits to the NCBI Nucleotide database)? The reason is that the ACNUC ‘genbank’ database does not contain all the sequences in the NCBI Nucleotide database, for example, it does not contain sequences that are in RefSeq or many short DNA sequences from sequencing projects. To obtain the accession numbers of the first five of the 19022 sequences, we can type: accessions &lt;- naturepaper$req accessions[1:5] [[1]] name length frame ncbicg “FN357292” “4179495” “0” “1” [[2]] name length frame ncbicg “FN357293” “2211188” “0” “1” [[3]] name length frame ncbicg “FN357294” “1818661” “0” “1” [[4]] name length frame ncbicg “FN357295” “2218116” “0” “1” [[5]] name length frame ncbicg “FN357296” “3831198” “0” “1” This tells us that the NCBI accessions of the first five sequences (of the 19022 DNA or RNA sequences found that were published in Nature 460:352-358) are FN357292, FN357293, FN357294, FN357295, and FN357296. To retrieve these first five sequences, and print out the first 10 nucleotide bases of each sequence, we use the getSequence() command, typing: for (i in 1:5) { seqi &lt;- getSequence(naturepaper\\(req[[i]]) print(seqi[1:10]) } [1] &quot;t&quot; &quot;t&quot; &quot;g&quot; &quot;t&quot; &quot;c&quot; &quot;g&quot; &quot;a&quot; &quot;t&quot; &quot;t&quot; &quot;a&quot; [1] &quot;g&quot; &quot;g&quot; &quot;t&quot; &quot;c&quot; &quot;c&quot; &quot;t&quot; &quot;t&quot; &quot;a&quot; &quot;a&quot; &quot;g&quot; [1] &quot;g&quot; &quot;c&quot; &quot;c&quot; &quot;t&quot; &quot;g&quot; &quot;a&quot; &quot;c&quot; &quot;c&quot; &quot;a&quot; &quot;t&quot; [1] &quot;t&quot; &quot;a&quot; &quot;t&quot; &quot;t&quot; &quot;t&quot; &quot;c&quot; &quot;c&quot; &quot;a&quot; &quot;a&quot; &quot;t&quot; [1] &quot;c&quot; &quot;a&quot; &quot;a&quot; &quot;t&quot; &quot;c&quot; &quot;a&quot; &quot;c&quot; &quot;t&quot; &quot;c&quot; &quot;a&quot; Note that the input to the getSequence() command is Dengue1\\)req[[i]], which contains the name of i th NCBI record that the list naturepaper contains information about. Once we have carried out our queries and retrieved the sequences, the final step is to close the connection to the ACNUC sub-database that we searched (“genbank” here): closebank() Saving sequence data in a FASTA-format file Once you have retrieved a sequence, or set of sequences from the NCBI Database, using SeqinR, it is conveninent to save the sequences in a file in FASTA format. This can be done using the “write.fasta()” function in the SeqinR package, which was introduced in Chapter 1. If you look at the help page for the “write.fasta()” function, you will see that as input it takes a list of vectors, where each vector contains one DNA, RNA or protein sequence. For example, if you retrieve the sequences of human tRNAs from the NCBI Database by querying the ACNUC “genbank” sub-database, you can save the sequences in a FASTA format file called “humantRNAs.fasta” by typing: choosebank(“genbank”) # select the ACNUC sub-database to be searched query(“humtRNAs”, “SP=homo sapiens AND M=TRNA”) # specify the query myseqs &lt;- getSequence(humtRNAs) # get the sequences mynames &lt;- getName(humtRNAs) # get the names of the sequences write.fasta(myseqs, mynames, file.out=“humantRNAs.fasta”) closebank() In the above code, we get the sequences of the human tRNAs using the function “getSequence()” from the SeqinR package. We also use a function “getName()” from the SeqinR package to get the sequences’ names. Then we use the “write.fasta()” function to write the sequences to a FASTA file “humantRNAs.fasta”. The “write.fasta()” takes as arguments: the list myseqs containing the sequences, the list mynames containing the names of the sequences, and the name of the output file (“humantRNAs.fasta” here). Finding the genome sequence for a particular species Microbial genomes are generally smaller than eukaryotic genomes (Escherichia coli has about 5 million base pair in its genome, while the human genome is about 3 billion base pairs). Because they are considerably less expensive to sequence, many microbial genome sequencing projects have been completed. If you don’t know the accession number for a genome sequence (eg. for Mycobacterium leprae, the bacterium that causes leprosy), how can you find it out? The easiest way to do this is to look at the NCBI Genome website, which lists all fully sequenced genomes and gives the accession numbers for the corresponding DNA sequences. If you didn’t know the accession number for the Mycobacterium leprae genome, you could find it on the NCBI Genome website by following these steps: Go to the NCBI Genome website (http://www.ncbi.nlm.nih.gov/sites/entrez?db=Genome) On the homepage of the NCBI Genome website, it gives links to the major subdivisions of the Genome database, which include Eukaryota, Prokaryota (Bacteria and Archaea), and Viruses. Click on ‘Prokaryota’, since Mycobacterium leprae is a bacterium. This will bring up a list of all fully sequenced bacterial genomes, with the corresponding accession numbers. Note that more than one genome (from various strains) may have been sequenced for a particular species. Use ‘Find’ in the ‘Edit’ menu of your web browser to search for ‘Mycobacterium leprae’ on the webpage. You should find that the genomes of several different M. leprae strains have been sequenced. One of these is M. leprae TN, which has accession number NC_002677. The list of sequenced genomes on the NCBI Genomes website is not a definitive list; that is, some sequenced genomes may be missing from this list. If you want to find out whether a particular genome has been sequenced, but you don’t find it NCBI Genomes website’s list, you should search for it by following these steps: Go to the NCBI website (www.ncbi.nlm.nih.gov). Select ‘Genome’ from the drop-down list above the search box. Type the name of the species you are interested in in the search box (eg. “Mycobacterium leprae”[ORGN]). Press ‘Search’. Note that you could also have found the Mycobacterium leprae genome sequence by searching the NCBI Nucleotide database, as the NCBI Genome database is just a subset of the NCBI Nucleotide database. How many genomes have been sequenced, or are being sequenced now? On the NCBI Genome website (http://www.ncbi.nlm.nih.gov/sites/entrez?db=Genome), the front page gives a link to a list of all sequenced genomes in the groups Eukaryota, Prokaryota (Bacteria and Archaea) and Viruses. If you click on one of these links (eg. Prokaryota), at the top of the page it will give the number of sequenced genomes in that group (eg. number of sequenced prokaryotic genomes). For example, in this screenshot (from January 2011), we see that there were 1409 complete prokaryotic genomes (94 archaeal, 1315 bacterial): image1 Another useful website that lists genome sequencing projects is the Genomes OnLine Database (GOLD), which lists genomes that have been completely sequenced, or are currently being sequenced. To find the number of complete or ongoing bacterial sequencing projects, follow these steps: Go to the GOLD website (http://genomesonline.org/). Click on the yellow ‘Enter GOLD’ button in the centre of the webpage. On the subsequent page, it will give the number of ongoing bacterial, archaeal and eukaryotic genome sequencing projects. Click on the ‘Bacterial Ongoing’ link to see the list of ongoing bacterial genome sequencing projects. By default, just the first 100 projects are listed, and the rest are listed on subsequent pages. In one of the columns of the page, this gives the university or institute that the genome was sequenced in. Other columns give the taxonomic information for the organism, and links to the sequence data. Find the number of published genome sequencing projects. Go back one page, to the page with the ‘Bacterial Ongoing’ link. You will see that this page also lists the number of complete published genomes. To see a list of these genomes, click on ‘Complete Published’. This will bring up a page that gives the number of published genomes at the top of the page. In one column of the page, this gives the university or institute that the genome was sequenced in. As explained above, it is possible to identify genome sequence data in the NCBI Genome database. The GOLD database also gives some information about ongoing genome projects. Often, the GOLD database lists some ongoing projects that are not yet present in the NCBI Genome Database, because the sequence data has not yet been submitted to the NCBI Database. If you are interested in finding out how many genomes have been sequenced or are currently being sequenced for a particular species (eg. Mycobacterium leprae), it is a good idea to look at both the NCBI Genome database and at GOLD. 11.2 Summary In this chapter, you have learnt how to retrieve sequences from the NCBI Sequence database, as well as to find out how many genomes have been sequenced or are currently being sequenced for a particular species. Links and Further Reading There is detailed information on how to search the NCBI database on the NCBI Help website at http://www.ncbi.nlm.nih.gov/bookshelf/br.fcgi?book=helpentrez?part=EntrezHelp. There is more information about the GOLD database in the paper describing GOLD by Liolios et al, which is available at http://www.ncbi.nlm.nih.gov/pmc/articles/PMC2808860/?tool=pubmed. For more in-depth information and more examples on using the SeqinR package for sequence analysis, look at the SeqinR documentation, http://pbil.univ-lyon1.fr/software/seqinr/doc.php?lang=eng. There is also a very nice chapter on “Analyzing Sequences”, which includes examples of using SeqinR for sequence analysis, in the book Applied statistics for bioinformatics using R by Krijnen (available online at cran.r-project.org/doc/contrib/Krijnen-IntroBioInfStatistics.pdf). 11.3 Acknowledgements ’ Contact I will be grateful if you will send me (Avril Coghlan) corrections or suggestions for improvements to my email address alc@sanger.ac.uk License The content in this book is licensed under a Creative Commons Attribution 3.0 License. Exercises Answer the following questions. For each question, please record your answer, and what you did/typed to get this answer. Model answers to the exercises are given in Answers to the exercises on Sequence Databases. What information about the rabies virus sequence (NCBI accession NC_001542) can you obtain from its annotations in the NCBI Sequence Database? What does it say in the DEFINITION and ORGANISM fields of its NCBI record? Note: rabies virus is the virus responsible for rabies, which is classified by the WHO as a neglected tropical disease. How many nucleotide sequences are there from the bacterium Chlamydia trachomatis in the NCBI Sequence Database? Note: the bacterium Chlamydia trachomatis is responsible for causing trachoma, which is classified by the WHO as a neglected tropical disease. How many nucleotide sequences are there from the bacterium Chlamydia trachomatis in the RefSeq part of the NCBI Sequence Database? How many nucleotide sequences were submitted to NCBI by Matthew Berriman? How many nucleotide sequences from nematode worms are there in the RefSeq Database? Note that several parasitic nematode worms cause neglected tropical diseases, including Brugia malayi and Wucheria bancrofti, which cause lymphatic filariasis; Loa loa, which causes subcutaneous filariasis; Onchocerca volvulus, which causes onchocerciasis; and Necator americanus, which causes soil-transmitted helminthiasis. How many nucleotide sequences for collagen genes from nematode worms are there in the NCBI Database? How many mRNA sequences for collagen genes from nematode worms are there in the NCBI Database? How many protein sequences for collagen proteins from nematode worms are there in the NCBI database? What is the accession number for the Trypanosoma cruzi genome in NCBI? Do you see genome sequences for more than one strain of Trypanosoma cruzi? Note that the Trypanosoma cruzi causes Chagas disease, which is classified as a neglected tropical disease by the WHO. How many fully sequenced nematode worm species are represented in the NCBI Genome database? "],["local-variation-in-gc-content-not-updated.html", "Chapter 12 Local variation in GC content - NOT UPDATED 12.1 Vocabulary 12.2 Reading sequence data with rentrez::entrez_fetch 12.3 Local variation in GC content 12.4 Acknowledgements 12.5 Exercises", " Chapter 12 Local variation in GC content - NOT UPDATED By: Avril Coghlan, adapted by Nathan Brouwer TODO need fasta clearn function put into biodata Preliminaries library(rentrez) library(seqinr) 12.0.1 Note on the biology in this section Some of the biology in this tutorial appears to be out of date. For example, using variation in GC content to ID horizontal gene transfer is currently considered to be biased. The examples are still good for practicing R skills. 12.1 Vocabulary GC content horizontal transfer local variation in GC content 12.2 Reading sequence data with rentrez::entrez_fetch In a previous section you learned how to use to search for and download the sequence data for a given NCBI accession from the NCBI Sequence Database, either via the NCBI website using entrez_fetch() from the rentrez package. For example, you could have downloaded the sequence data for a the DEN-1 Dengue virus sequence (NCBI accession NC_001477), and stored it on a file on your computer (eg. “dengue_fasta.fasta”). dengueseq_fasta &lt;- entrez_fetch(db = &quot;nucleotide&quot;, id = &quot;NC_001477&quot;, rettype = &quot;fasta&quot;) As noted before, the file gets downloaded in FASTA format, which isn’t directly useable in R We can convert our FASTA object into a vector using the function fasta_cleaner() header. &lt;- &quot;&gt;NC_001477.1 Dengue virus 1, complete genome&quot; dengueseq_vector &lt;- fasta_cleaner(dengueseq_fasta) Once you have retrieved a sequence from the NCBI Sequence Database and stored it in a vector variable such as dengueseq_vector in the example above, it is possible to extract subsequence of the sequence by typing the name of the vector (eg. dengueseq_vector) followed by the square brackets containing the indices for those nucleotides. For example, to obtain nucleotides 452-535 of the DEN-1 Dengue virus genome, we can type: dengueseq_vector[452:535] 12.3 Local variation in GC content In a previous section, you learned that to find out the GC content of a genome sequence (percentage of nucleotides in a genome sequence that are Gs or Cs), you can use the GC() function in the SeqinR package. For example, to find the GC content of the DEN-1 Dengue virus sequence that we have stored in the vector dengueseq, we can type: GC(dengueseq_vector) The output of the GC() is the fraction of nucleotides in a sequence that are Gs or Cs, so to convert it to a percentage we need to multiply by 100. GC(dengueseq_vector)*100 Thus, the GC content of the DEN-1 Dengue virus genome is about 0.467 or 46.7%. Although the GC content of the whole DEN-1 Dengue virus genome sequence is about 46.7%, there is probably local variation in GC content within the genome. That is, some regions of the genome sequence may have GC contents quite a bit higher than 46.7%, while some regions of the genome sequence may have GC contents that are quite a big lower than 46.7%. Local fluctuations in GC content within the genome sequence can provide different interesting information, for example, they may reveal cases of horizontal transfer or reveal biases in mutation. If a chunk of DNA has moved by horizontal transfer from the genome of a species with low GC content to a species with high GC content, the chunk of horizontally transferred DNA could be detected as a region of unusually low GC content in the high-GC recipient genome. On the other hand, a region unusually low GC content in an otherwise high-GC content genome could also arise due to biases in mutation in that region of the genome, for example, if mutations from Gs/Cs to Ts/As are more common for some reason in that region of the genome than in the rest of the genome. A sliding window analysis of GC content In order to study local variation in GC content within a genome sequence, we could calculate the GC content for small chunks of the genome sequence. The DEN-1 Dengue virus genome sequence is 10735 nucleotides long. To study variation in GC content within the genome sequence, we could calculate the GC content of chunks of the DEN-1 Dengue virus genome, for example, for each 2000-nucleotide chunk of the genome sequence: GC(dengueseq[1:2000]) # Calculate the GC content of nucleotides 1-2000 of the Dengue genome GC(dengueseq[2001:4000]) # Calculate the GC content of nucleotides 2001-4000 of the Dengue genome From the output of the above calculations, we see that the region of the DEN-1 Dengue virus genome from nucleotides 1-2000 has a GC content of 46.5%, while the region of the Dengue genome from nucleotides 2001-4000 has a GC content of about 45.3%. Thus, there seems to be some local variation in GC content within the Dengue genome sequence. Instead of typing in the commands above to tell R to calculate the GC content for each 2000-nucleotide chunk of the DEN-1 Dengue genome, we can use a for loop to carry out the same calculations, but by typing far fewer commands. That is, we can use a for loop to take each 2000-nucleotide chunk of the DEN-1 Dengue virus genome, and to calculate the GC content of each 2000-nucleotide chunk. Below we will explain the following for loop that has been written for this purpose: starts &lt;- seq(1, length(dengueseq)-2000, by = 2000) starts n &lt;- length(starts) # Find the length of the vector “starts” for (i in 1:n) { chunk &lt;- dengueseq[starts[i]:(starts[i]+1999)] chunkGC &lt;- GC(chunk) print (chunkGC) } The command “starts &lt;- seq(1, length(dengueseq)-2000, by = 2000)” stores the result of the seq() command in the vector starts, which contains the values 1, 2001, 4001, 6001, and 8001. We set the variable n to be equal to the number of elements in the vector starts, so it will be 5 here, since the vector starts contains the five elements 1, 2001, 4001, 6001 and 8001. The line “for (i in 1:n)” means that the counter i will take values of 1-5 in subsequent cycles of the for loop. The for loop above is spread over several lines. However, R will not execute the commands within the for loop until you have typed the final “}” at the end of the for loop and pressed “Return”. Each of the three commands within the for loop are carried out in each cycle of the loop. In the first cycle of the loop, i is 1, the vector variable chunk is used to store the region from nucleotides 1-2000 of the Dengue virus sequence, the GC content of that region is calculated and stored in the variable chunkGC, and the value of chunkGC is printed out. In the second cycle of the loop, i is 2, the vector variable chunk is used to store the region from nucleotides 2001-4000 of the Dengue virus sequence, the GC content of that region is calculated and stored in the variable chunkGC, and the value of chunkGC is printed out. The loop continues until the value of i is 5. In the fifth cycle through the loop, the value of i is 5, and so the GC content of the region from nucleotides 8001-10000 is printed out. Note that we stop the loop when we are looking at the region from nucleotides 8001-10000, instead of continuing to another cycle of the loop where the region under examiniation would be from nucleotides 10001-12000. The reason for this is because the length of the Dengue virus genome sequence is just 10735 nucleotides, so there is not a full 2000-nucleotide region from nucleotide 10001 to the end of the sequence at nucleotide 10735. The above analysis of local variation in GC content is what is known as a sliding window analysis of GC content. By calculating the GC content in each 2000-nucleotide chunk of the Dengue virus genome, you are effectively sliding a 2000-nucleotide window along the DNA sequence from start to end, and calculating the GC content in each non-overlapping window (chunk of DNA). Note that this sliding window analysis of GC content is a slightly simplified version of the method usually carried out by bioinformaticians. In this simplified version, we have calculated the GC content in non-overlapping windows along a DNA sequence. However, it is more usual to calculate GC content in overlapping windows along a sequence, although that makes the code slightly more complicated. A sliding window plot of GC content It is common to use the data generated from a sliding window analysis to create a sliding window plot of GC content. To create a sliding window plot of GC content, you plot the local GC content in each window of the genome, versus the nucleotide position of the start of each window. We can create a sliding window plot of GC content by typing: starts &lt;- seq(1, length(dengueseq)-2000, by = 2000) n &lt;- length(starts) # Find the length of the vector “starts” chunkGCs &lt;- numeric(n) # Make a vector of the same length as vector “starts”, but just containing zeroes for (i in 1:n) { chunk &lt;- dengueseq[starts[i]:(starts[i]+1999)] chunkGC &lt;- GC(chunk) print(chunkGC) chunkGCs[i] &lt;- chunkGC } plot(starts,chunkGCs,type=“b”,xlab=“Nucleotide start position”,ylab=“GC content”) image2 In the code above, the line “chunkGCs &lt;- numeric(n)” makes a new vector chunkGCs which has the same number of elements as the vector starts (5 elements here). This vector chunkGCs is then used within the for loop for storing the GC content of each chunk of DNA. After the loop, the vector starts can be plotted against the vector chunkGCs using the plot() function, to get a plot of GC content against nucleotide position in the genome sequence. This is a sliding window plot of GC content. You may want to use the code above to create sliding window plots of GC content of different species’ genomes, using different windowsizes. Therefore, it makes sense to write a function to do the sliding window plot, that can take the windowsize that the user wants to use and the sequence that the user wants to study as arguments (inputs): slidingwindowplot &lt;- function(windowsize, inputseq) { starts &lt;- seq(1, length(inputseq)-windowsize, by = windowsize) n &lt;- length(starts) # Find the length of the vector “starts” chunkGCs &lt;- numeric(n) # Make a vector of the same length as vector “starts”, but just containing zeroes for (i in 1:n) { chunk &lt;- inputseq[starts[i]:(starts[i]+windowsize-1)] chunkGC &lt;- GC(chunk) print(chunkGC) chunkGCs[i] &lt;- chunkGC } plot(starts,chunkGCs,type=“b”,xlab=“Nucleotide start position”,ylab=“GC content”) } This function will make a sliding window plot of GC content for a particular input sequence inputseq specified by the user, using a particular windowsize windowsize specified by the user. Once you have typed in this function once, you can use it again and again to make sliding window plots of GC contents for different input DNA sequences, with different windowsizes. For example, you could create two different sliding window plots of the DEN-1 Dengue virus genome sequence, using windowsizes of 3000 and 300 nucleotides, respectively: slidingwindowplot(3000, dengueseq) image3 slidingwindowplot(300, dengueseq) image4 Over-represented and under-represented DNA words In the previous chapter, you learned that the count() function in the SeqinR R package can calculate the frequency of all DNA words of a certain length in a DNA sequence. For example, if you want to know the frequency of all DNA words that are 2 nucleotides long in the Dengue virus genome sequence, you can type: count(dengueseq, 2) aa ac ag at ca cc cg ct ga gc gg gt ta tc tg tt 1108 720 890 708 901 523 261 555 976 500 787 507 440 497 832 529 It is interesting to identify DNA words that are two nucleotides long (“dinucleotides”, ie. “AT”, “AC”, etc.) that are over-represented or under-represented in a DNA sequence. If a particular DNA word is over-represented in a sequence, it means that it occurs many more times in the sequence than you would have expected by chance. Similarly, if a particular DNA word is under-represented in a sequence, it means it occurs far fewer times in the sequence than you would have expected. A statistic called ρ (Rho) is used to measure how over- or under-represented a particular DNA word is. For a 2-nucleotide (dinucleotide) DNA word ρ is calculated as: ρ(xy) = fxy/(fx*fy), where fxy and fx are the frequencies of the DNA words xy and x in the DNA sequence under study. For example, the value of ρ for the DNA word “TA” can be calculated as: ρ(TA) = fTA/(fT* fA), where fTA, fT and fA are the frequencies of the DNA words “TA”, “T” and “A” in the DNA sequence. The idea behind the ρ statistic is that, if a DNA sequence had a frequency fx of a 1-nucleotide DNA word x, and a frequency fy of a 1-nucleotide DNA word y, then we expect the frequency of the 2-nucleotide DNA word xy to be fx* fy. That is, the frequencies of the 2-nucleotide DNA words in a sequence are expected to be equal the products of the specific frequencies of the two nucleotides that compose them. If this were true, then ρ would be equal to 1. If we find that ρ is much greater than 1 for a particular 2-nucleotide word in a sequence, it indicates that that 2-nucleotide word is much more common in that sequence than expected (ie. it is over-represented). For example, say that your input sequence has only 5% Ts (ie. fT = 0.05). In a random DNA sequence with 5% Ts, you would expect to see the word “TT” very infrequently. In fact, we would only expect 0.05 * 0.05=0.0025 (0.25%) of 2-nucleotide words to be TTs (ie. we expect fTT = fT* fT). This is because Ts are rare, so they are expected to be adjacent to each other very infrequently if the few Ts are randomly scattered throughout the DNA. Therefore, if you see lots of TT 2-nucleotide words in your real input sequence (eg. fTT = 0.3, so ρ = 0.3/0.0025 = 120), you would suspect that natural selection has acted to increase the number of occurrences of the TT word in the sequence (presumably because it has some beneficial biological function). To find over-represented and under-represented DNA words that are 2 nucleotides long in the DEN-1 Dengue virus sequence, we can calculate the ρ statistic for each 2-nucleotide word in the sequence. For example, given the number of occurrences of the individual nucleotides A, C, G and T in the Dengue sequence, and the number of occurrences of the DNA word GC in the sequence (500, from above), we can calculate the value of ρ for the 2-nucleotide DNA word “GC”, using the formula ρ(GC) = fGC/(fG * fC), where fGC, fG and fC are the frequencies of the DNA words “GC”, “G” and “C” in the DNA sequence: count(dengueseq, 1) # Get the number of occurrences of 1-nucleotide DNA words a c g t 3426 2240 2770 2299 2770/(3426+2240+2770+2299) # Get fG [1] 0.2580345 2240/(3426+2240+2770+2299) # Get fC [1] 0.2086633 count(dengueseq, 2) # Get the number of occurrences of 2-nucleotide DNA words aa ac ag at ca cc cg ct ga gc gg gt ta tc tg tt 1108 720 890 708 901 523 261 555 976 500 787 507 440 497 832 529 500/(1108+720+890+708+901+523+261+555+976+500+787+507+440+497+832+529) # Get fGC [1] 0.04658096 0.04658096/(0.2580345*0.2086633) # Get rho(GC) [1] 0.8651364 We calculate a value of ρ(GC) of approximately 0.865. This means that the DNA word “GC” is about 0.865 times as common in the DEN-1 Dengue virus sequence than expected. That is, it seems to be slightly under-represented. Note that if the ratio of the observed to expected frequency of a particular DNA word is very low or very high, then we would suspect that there is a statistical under-representation or over-representation of that DNA word. However, to be sure that this over- or under-representation is statistically significant, we would need to do a statistical test. We will not deal with the topic of how to carry out the statistical test here. Summary In this chapter, you will have learned to use the following R functions: seq() for creating a sequence of numbers print() for printing out the value of a variable plot() for making a plot (eg. a scatterplot) numeric() for making a numeric vector of a particular length function() for making a function All of these functions belong to the standard installation of R. You also learned how to use for loops to carry out the same operation again and again, each time on different inputs. Links and Further Reading Some links are included here for further reading. For background reading on DNA sequence statistics, it is recommended to read Chapter 1 of Introduction to Computational Genomics: a case studies approach by Cristianini and Hahn (Cambridge University Press; www.computational-genomics.net/book/). For more in-depth information and more examples on using the SeqinR package for sequence analysis, look at the SeqinR documentation, http://pbil.univ-lyon1.fr/software/seqinr/doc.php?lang=eng. There is also a very nice chapter on “Analyzing Sequences”, which includes examples of using SeqinR for sequence analysis, in the book Applied statistics for bioinformatics using R by Krijnen (available online at cran.r-project.org/doc/contrib/Krijnen-IntroBioInfStatistics.pdf). For a more in-depth introduction to R, a good online tutorial is available on the “Kickstarting R” website, cran.r-project.org/doc/contrib/Lemon-kickstart. There is another nice (slightly more in-depth) tutorial to R available on the “Introduction to R” website, cran.r-project.org/doc/manuals/R-intro.html. Acknowledgements Thank you to Noel O’Boyle for helping in using Sphinx, http://sphinx.pocoo.org, to create this document, and github, https://github.com/, to store different versions of the document as I was writing it, and readthedocs, http://readthedocs.org/, to build and distribute this document. 12.4 Acknowledgements This is a modification of “DNA Sequence Statistics (1)” from Avril Coghlan’s A little book of R for bioinformatics.. Almost all of text and code was originally written by Dr. Coghlan and distributed under the Creative Commons 3.0 license. In “A little book…” Coghlan write “Many of the ideas for the examples and exercises for this chapter were inspired by the Matlab case studies on Haemophilus influenzae (www.computational-genomics.net/case_studies/haemophilus_demo.html) and Bacteriophage lambda (http://www.computational-genomics.net/case_studies/lambdaphage_demo.html) from the website that accompanies the book Introduction to Computational Genomics: a case studies approach by Cristianini and Hahn (Cambridge University Press; www.computational-genomics.net/book/).” 12.4.1 License The content in this book is licensed under a Creative Commons Attribution 3.0 License. 12.5 Exercises Answer the following questions, using the R package. For each question, please record your answer, and what you typed into R to get this answer. Model answers to the exercises are given in Answers to the exercises on DNA Sequence Statistics (2). Draw a sliding window plot of GC content in the DEN-1 Dengue virus genome, using a window size of 200 nucleotides. Do you see any regions of unusual DNA content in the genome (eg. a high peak or low trough)? Make a sketch of each plot that you draw. At what position (in base-pairs) in the genome is there the largest change in local GC content (approximate position is fine here)? Compare the sliding window plots of GC content created using window sizes of 200 and 2000 nucleotides. How does window size affect your ability to detect differences within the Dengue virus genome? Draw a sliding window plot of GC content in the genome sequence for the bacterium Mycobacterium leprae strain TN (accession NC_002677) using a window size of 20000 nucleotides. Do you see any regions of unusual DNA content in the genome (eg. a high peak or low trough)? Make a sketch of each plot that you drew for the previous quetion. Write down the approximate nucleotide position of the highest peak or lowest trough that you see. Why do you think a window size of 20000 nucleotides was chosen? What do you see if you use a much smaller windowsize (eg. 200 nucleotides) or a much larger windowsize (eg. 200,000 nucleotides)? Advanced: Write a function to calculate the AT content of a DNA sequence (ie. the fraction of the nucleotides in the sequence that are As or Ts). What is the AT content of the Mycobacterium leprae TN genome? Hint: use the function count() to make a table containing the number of As, Gs, Ts and Cs in the sequence. Remember that function count() produces a table object, and you can access the elements of a table object using double square brackets. Do you notice a relationship between the AT content of the Mycobacterium leprae TN genome, and its GC content? Advanced: Write a function to draw a sliding window plot of AT content. Use it to make a sliding window plot of AT content along the Mycobacterium leprae TN genome, using a windowsize of 20000 nucleotides. Do you notice any relationship between the sliding window plot of GC content along the Mycobacterium leprae genome, and the sliding window plot of AT content? Make a sketch of the plot that you draw. Is the 3-nucleotide word GAC GC over-represented or under-represented in the Mycobacterium leprae TN genome sequence? What is the frequency of this word in the sequence? What is the expected frequency of this word in the sequence? What is the p (Rho) value for this word? How would you figure out whether there is already an R function to calculate p (Rho)? Is there one that you could use? "],["alignments-in-r-not-updayed.html", "Chapter 13 Alignments in R - NOT UPDAYED 13.1 Retrieving a UniProt protein sequence using SeqinR 13.2 Comparing two sequences using a dotplot 13.3 Aligning UniProt sequences", " Chapter 13 Alignments in R - NOT UPDAYED 13.1 Retrieving a UniProt protein sequence using SeqinR An alternative method of retrieving a UniProt protein sequence is to use the SeqinR package to query the ACNUC sub-database “swissprot”, which contains protein sequences from UniProt. We use the query() function from SeqinR to query this database, as described in chapter3. For example to retrieve the protein sequences for UniProt accessions Q9CD83 and A0PQ23, we type in R: library(&quot;seqinr&quot;) choosebank(&quot;swissprot&quot;) query(&quot;leprae&quot;, &quot;AC=Q9CD83&quot;) lepraeseq &lt;- getSequence(leprae$req[[1]]) query(&quot;ulcerans&quot;, &quot;AC=A0PQ23&quot;) ulceransseq &lt;- getSequence(ulcerans$req[[1]]) closebank() Display the contents of “lepraeseq” lepraeseq 13.2 Comparing two sequences using a dotplot As a first step in comparing two protein, RNA or DNA sequences, it is a good idea to make a dotplot. A dotplot is a graphical method that allows the comparison of two protein or DNA sequences and identify regions of close similarity between them. A dotplot is essentially a two-dimensional matrix (like a grid), which has the sequences of the proteins being compared along the vertical and horizontal axes. In order to make a simple dotplot to represent of the similarity between two sequences, individual cells in the matrix can be shaded black if residues are identical, so that matching sequence segments appear as runs of diagonal lines across the matrix. Identical proteins will have a line exactly on the main diagonal of the dotplot, that spans across the whole matrix. For proteins that are not identical, but share regions of similarity, the dotplot will have shorter lines that may be on the main diagonal, or off the main diagonal of the matrix. In essence, a dotplot will reveal if there are any regions that are clearly very similar in two protein (or DNA) sequences. We can create a dotplot for two sequences using the “dotPlot()” function in the SeqinR R package. For example, if we want to create a dotplot of the sequences for the chorismate lyase proteins from Mycobacterium leprae and Mycobacterium ulcerans, we would type: dotPlot(lepraeseq, ulceransseq) image5 In the dotplot above, the M. leprae sequence is plotted along the x-axis (horizontal axis), and the M. ulcerans sequence is plotted along the y-axis (vertical axis). The dotplot displays a dot at points where there is an identical amino acid in the two sequences. For example, if amino acid 53 in the M. leprae sequence is the same amino acid (eg. “W”) as amino acid 70 in the M. ulcerans sequence, then the dotplot will show a dot the position in the plot where x =50 and y =53. In this case you can see a lot of dots along a diagonal line, which indicates that the two protein sequences contain many identical amino acids at the same (or very similar) positions along their lengths. This is what you would expect, because we know that these two proteins are homologues (related proteins). Pairwise global alignment of DNA sequences using the Needleman-Wunsch algorithm If you are studying a particular pair of genes or proteins, an important question is to what extent the two sequences are similar. To quantify similarity, it is necessary to align the two sequences, and then you can calculate a similarity score based on the alignment. There are two types of alignment in general. A global alignment is an alignment of the full length of two sequences, for example, of two protein sequences or of two DNA sequences. A local alignment is an alignment of part of one sequence to part of another sequence. The first step in computing a alignment (global or local) is to decide on a scoring system. For example, we may decide to give a score of +2 to a match and a penalty of -1 to a mismatch, and a penalty of -2 to a gap. Thus, for the alignment: G A A T T C G A T T - A we would compute a score of 2 + 2 -1 + 2 -2 - 1 = 2. Similarly, the score for the following alignment is 2 + 2 -2 + 2 + 2 -1 = 5: G A A T T C G A - T T A The scoring system above can be represented by a scoring matrix (also known as a substitution matrix). The scoring matrix has one row and one column for each possible letter in our alphabet of letters (eg. 4 rows and 4 columns for DNA sequences). The (i,j) element of the matrix has a value of +2 in case of a match and -1 in case of a mismatch. We can make a scoring matrix in R by using the nucleotideSubstitutionMatrix() function in the Biostrings() package. The Biostrings package is part of a set of R packages for bioinformatics analysis known as Bioconductor (www.bioconductor.org/). To use the Biostrings package, you will first need to install the package (see the instructions here). The arguments (inputs) for the nucleotideSubstitutionMatrix() function are the score that we want to assign to a match and the score that we want to assign to a mismatch. We can also specify that we want to use only the four letters representing the four nucleotides (ie. A, C, G, T) by setting ‘baseOnly=TRUE’, or whether we also want to use the letters that represent ambiguous cases where we are not sure what the nucleotide is (eg. ‘N’ = A/C/G/T). To make a scoring matrix which assigns a score of +2 to a match and -1 to a mismatch, and store it in the variable sigma, we type: dotPlot(lepraeseq, ulceransseq) Instead of assigning the same penalty (eg. -8) to every gap position, it is common instead to assign a gap opening penalty to the first position in a gap (eg. -8), and a smaller gap extension penalty to every subsequent position in the same gap. The reason for doing this is that it is likely that adjacent gap positions were created by the same insertion or deletion event, rather than by several independent insertion or deletion events. Therefore, we don’t want to penalise a 3-letter gap as much as we would penalise three separate 1-letter gaps, as the 3-letter gap may have arisen due to just one insertion or deletion event, while the 3 separate 1-letter gaps probably arose due to three independent insertion or deletion events. For example, if we want to compute the score for a global alignment of two short DNA sequences ‘GAATTC’ and ‘GATTA’, we can use the Needleman-Wunsch algorithm to calculate the highest-scoring alignment using a particular scoring function. The “pairwiseAlignment()” function in the Biostrings R package finds the score for the optimal global alignment between two sequences using the Needleman-Wunsch algorithm, given a particular scoring system. As arguments (inputs), the pairwiseAlignment() function takes the two sequences that you want to align, the scoring matrix, the gap opening penalty, and the gap extension penalty. You can also tell the function that you want to just have the optimal global alignment’s score by setting “scoreOnly = TRUE”, or that you want to have both the optimal global alignment and its score by setting “scoreOnly = FALSE”. For example, to find the score for the optimal global alignment between the sequences ‘GAATTC’ and ‘GATTA’, we type: s1 &lt;- &quot;GAATTC&quot; s2 &lt;- &quot;GATTA&quot; globalAligns1s2 &lt;- pairwiseAlignment(s1, s2, substitutionMatrix = sigma, gapOpening = -2, gapExtension = -8, scoreOnly = FALSE) globalAligns1s2 # Print out the optimal alignment and its score The above commands print out the optimal global alignment for the two sequences and its score. Note that we set “gapOpening” to be -2 and “gapExtension” to be -8, which means that the first position of a gap is assigned a score of (-8-2=)-10, and every subsequent position in a gap is given a score of -8. Here the alignment contains four matches, one mismatch, and one gap of length 1, so its score is (42)+(1-1)+(1*-10) = -3. Pairwise global alignment of protein sequences using the Needleman-Wunsch algorithm As well as DNA alignments, it is also possible to make alignments of protein sequences. In this case it is necessary to use a scoring matrix for amino acids rather than for nucleotides. There are several well known scoring matrices that come with R, such as the BLOSUM series of matrices. Different BLOSUM matrices exist, named with different numbers. BLOSUM with high numbers are designed for comparing closely related sequences, while BLOSUM with low numbers are designed for comparing distantly related sequences. For example, BLOSUM62 is used for less divergent alignments (alignments of sequences that differ little), and BLOSUM30 is used for more divergent alignments (alignments of sequences that differ a lot). Many R packages come with example data sets or data files. The “data()” function is used to load these data files. You can use the data() function in R to load a data set of BLOSUM matrices that comes with R Biostrings() package. To load the BLOSUM50 matrix, we type: data(BLOSUM50) BLOSUM50 # Print out the data You can get a list of the available scoring matrices that come with the Biostrings package by using the data() function, which takes as an argument the name of the package for which you want to know the data sets that come with it: data(package=&quot;Biostrings&quot;) To find the optimal global alignment between the protein sequences “PAWHEAE” and “HEAGAWGHEE” using the Needleman-Wunsch algorithm using the BLOSUM50 matrix, we type: data(BLOSUM50) s3 &lt;- &quot;PAWHEAE&quot; s4 &lt;- &quot;HEAGAWGHEE&quot; globalAligns3s4 &lt;- pairwiseAlignment(s3, s4, substitutionMatrix = &quot;BLOSUM50&quot;, gapOpening = -2, gapExtension = -8, scoreOnly = FALSE) globalAligns3s4 # Print out the optimal global alignment and its score We set “gapOpening” to be -2 and “gapExtension” to be -8, which means that the first position of a gap is assigned a score of (-8-2=)-10, and every subsequent position in a gap is given a score of -8. This means that the gap will be given a score of -10-8-8 = -26. 13.3 Aligning UniProt sequences We discussed above how you can search for UniProt accessions and retrieve the corresponding protein sequences, either via the UniProt website or using the SeqinR R package. In the examples given above, you learned how to retrieve the sequences for the chorismate lyase proteins from Mycobacterium leprae (UniProt Q9CD83) and Mycobacterium ulcerans (UniProt A0PQ23), and read them into R, and store them as vectors lepraeseq and ulceransseq. You can align these sequences using pairwiseAlignment() from the Biostrings package. As its input, the pairwiseAlignment() function requires that the sequences be in the form of a single string (eg. “ACGTA”), rather than as a vector of characters (eg. a vector with the first element as “A”, the second element as “C”, etc.). Therefore, to align the M. leprae and M. ulcerans chorismate lyase proteins, we first need to convert the vectors lepraeeq and ulceransseq into strings. We can do this using the c2s() function in the SeqinR package: lepraeseqstring &lt;- c2s(lepraeseq) # Make a string that contains the sequence in &quot;lepraeseq&quot; ulceransseqstring &lt;- c2s(ulceransseq) # Make a string that contains the sequence in &quot;ulceransseq&quot; Furthermore, pairwiseAlignment() requires that the sequences be stored as uppercase characters. Therefore, if they are not already in uppercase, we need to use the toupper() function to convert lepraeseqstring and ulceransseqstring to uppercase: lepraeseqstring &lt;- toupper(lepraeseqstring) ulceransseqstring &lt;- toupper(ulceransseqstring) lepraeseqstring # Print out the content of &quot;lepraeseqstring&quot; We can now align the the M. leprae and M. ulcerans chorismate lyase protein sequences using the pairwiseAlignment() function: globalAlignLepraeUlcerans &lt;- pairwiseAlignment(lepraeseqstring, ulceransseqstring, substitutionMatrix = BLOSUM50, gapOpening = -2, gapExtension = -8, scoreOnly = FALSE) globalAlignLepraeUlcerans # Print out the optimal global alignment and its score As the alignment is very long, when you type globalAlignLepraeUlcerans, you only see the start and the end of the alignment (see above). Therefore, we need to have a function to print out the whole alignment (see below). Viewing a long pairwise alignment If you want to view a long pairwise alignment such as that between the M. leprae and M. ulerans chorismate lyase proteins, it is convenient to print out the alignment in blocks. The R function “printPairwiseAlignment()” below will do this for you: To use this function you first need to copy and paste this function into R. You can then use our function printPairwiseAlignment() to print out the alignment between the M. leprae and M. ulcerans chorismate lyase proteins (we stored this alignment in the globalAlignLepraeUlcerans variable, see above), in blocks of 60 alignment columns: printPairwiseAlignment(globalAlignLepraeUlcerans, 60) The position in the protein of the amino acid that is at the end of each line of the printed alignment is shown after the end of the line. For example, the first line of the alignment above finishes at amino acid position 50 in the M. leprae protein and also at amino acid position 60 in the M. ulcerans protein. Since we are printing out an alignment that contained gaps in the first 60 alignment columns, the first 60 alignment columns ends before the 60th amino acid in the M. leprae sequence. Pairwise local alignment of protein sequences using the Smith-Waterman algorithm You can use the pairwiseAlignment() function to find the optimal local alignment of two sequences, that is the best alignment of parts (subsequences) of those sequences, by using the “type=local” argument in pairwiseAlignment(). This uses the Smith-Waterman algorithm for local alignment, the classic bioinformatics algorithm for finding optimal local alignments. For example, to find the best local alignment between the M. leprae and M. ulcerans chorismate lyase proteins, we can type: localAlignLepraeUlcerans &lt;- pairwiseAlignment(lepraeseqstring, ulceransseqstring, substitutionMatrix = BLOSUM50, gapOpening = -2, gapExtension = -8, scoreOnly = FALSE, type=&quot;local&quot;) Print out the optimal local alignment and its score localAlignLepraeUlcerans printPairwiseAlignment(localAlignLepraeUlcerans, 60) We see that the optimal local alignment is quite similar to the optimal global alignment in this case, except that it excludes a short region of poorly aligned sequence at the start and at the ends of the two proteins. "],["references.html", "References", " References "]]
